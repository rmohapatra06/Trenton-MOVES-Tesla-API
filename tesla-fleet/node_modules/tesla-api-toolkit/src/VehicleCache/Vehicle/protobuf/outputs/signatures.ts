// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.6.0
//   protoc               v3.12.4
// source: signatures.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";

export const protobufPackage = "Signatures";

export enum Tag {
  TAG_SIGNATURE_TYPE = 0,
  TAG_DOMAIN = 1,
  TAG_PERSONALIZATION = 2,
  TAG_EPOCH = 3,
  TAG_EXPIRES_AT = 4,
  TAG_COUNTER = 5,
  TAG_CHALLENGE = 6,
  TAG_FLAGS = 7,
  TAG_REQUEST_HASH = 8,
  TAG_FAULT = 9,
  TAG_END = 255,
  UNRECOGNIZED = -1,
}

export function tagFromJSON(object: any): Tag {
  switch (object) {
    case 0:
    case "TAG_SIGNATURE_TYPE":
      return Tag.TAG_SIGNATURE_TYPE;
    case 1:
    case "TAG_DOMAIN":
      return Tag.TAG_DOMAIN;
    case 2:
    case "TAG_PERSONALIZATION":
      return Tag.TAG_PERSONALIZATION;
    case 3:
    case "TAG_EPOCH":
      return Tag.TAG_EPOCH;
    case 4:
    case "TAG_EXPIRES_AT":
      return Tag.TAG_EXPIRES_AT;
    case 5:
    case "TAG_COUNTER":
      return Tag.TAG_COUNTER;
    case 6:
    case "TAG_CHALLENGE":
      return Tag.TAG_CHALLENGE;
    case 7:
    case "TAG_FLAGS":
      return Tag.TAG_FLAGS;
    case 8:
    case "TAG_REQUEST_HASH":
      return Tag.TAG_REQUEST_HASH;
    case 9:
    case "TAG_FAULT":
      return Tag.TAG_FAULT;
    case 255:
    case "TAG_END":
      return Tag.TAG_END;
    case -1:
    case "UNRECOGNIZED":
    default:
      return Tag.UNRECOGNIZED;
  }
}

export function tagToJSON(object: Tag): string {
  switch (object) {
    case Tag.TAG_SIGNATURE_TYPE:
      return "TAG_SIGNATURE_TYPE";
    case Tag.TAG_DOMAIN:
      return "TAG_DOMAIN";
    case Tag.TAG_PERSONALIZATION:
      return "TAG_PERSONALIZATION";
    case Tag.TAG_EPOCH:
      return "TAG_EPOCH";
    case Tag.TAG_EXPIRES_AT:
      return "TAG_EXPIRES_AT";
    case Tag.TAG_COUNTER:
      return "TAG_COUNTER";
    case Tag.TAG_CHALLENGE:
      return "TAG_CHALLENGE";
    case Tag.TAG_FLAGS:
      return "TAG_FLAGS";
    case Tag.TAG_REQUEST_HASH:
      return "TAG_REQUEST_HASH";
    case Tag.TAG_FAULT:
      return "TAG_FAULT";
    case Tag.TAG_END:
      return "TAG_END";
    case Tag.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum SignatureType {
  SIGNATURE_TYPE_AES_GCM = 0,
  SIGNATURE_TYPE_AES_GCM_PERSONALIZED = 5,
  SIGNATURE_TYPE_HMAC = 6,
  SIGNATURE_TYPE_HMAC_PERSONALIZED = 8,
  SIGNATURE_TYPE_AES_GCM_RESPONSE = 9,
  UNRECOGNIZED = -1,
}

export function signatureTypeFromJSON(object: any): SignatureType {
  switch (object) {
    case 0:
    case "SIGNATURE_TYPE_AES_GCM":
      return SignatureType.SIGNATURE_TYPE_AES_GCM;
    case 5:
    case "SIGNATURE_TYPE_AES_GCM_PERSONALIZED":
      return SignatureType.SIGNATURE_TYPE_AES_GCM_PERSONALIZED;
    case 6:
    case "SIGNATURE_TYPE_HMAC":
      return SignatureType.SIGNATURE_TYPE_HMAC;
    case 8:
    case "SIGNATURE_TYPE_HMAC_PERSONALIZED":
      return SignatureType.SIGNATURE_TYPE_HMAC_PERSONALIZED;
    case 9:
    case "SIGNATURE_TYPE_AES_GCM_RESPONSE":
      return SignatureType.SIGNATURE_TYPE_AES_GCM_RESPONSE;
    case -1:
    case "UNRECOGNIZED":
    default:
      return SignatureType.UNRECOGNIZED;
  }
}

export function signatureTypeToJSON(object: SignatureType): string {
  switch (object) {
    case SignatureType.SIGNATURE_TYPE_AES_GCM:
      return "SIGNATURE_TYPE_AES_GCM";
    case SignatureType.SIGNATURE_TYPE_AES_GCM_PERSONALIZED:
      return "SIGNATURE_TYPE_AES_GCM_PERSONALIZED";
    case SignatureType.SIGNATURE_TYPE_HMAC:
      return "SIGNATURE_TYPE_HMAC";
    case SignatureType.SIGNATURE_TYPE_HMAC_PERSONALIZED:
      return "SIGNATURE_TYPE_HMAC_PERSONALIZED";
    case SignatureType.SIGNATURE_TYPE_AES_GCM_RESPONSE:
      return "SIGNATURE_TYPE_AES_GCM_RESPONSE";
    case SignatureType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum SessionInfoStatus {
  SESSION_INFO_STATUS_OK = 0,
  SESSION_INFO_STATUS_KEY_NOT_ON_WHITELIST = 1,
  UNRECOGNIZED = -1,
}

export function sessionInfoStatusFromJSON(object: any): SessionInfoStatus {
  switch (object) {
    case 0:
    case "SESSION_INFO_STATUS_OK":
      return SessionInfoStatus.SESSION_INFO_STATUS_OK;
    case 1:
    case "SESSION_INFO_STATUS_KEY_NOT_ON_WHITELIST":
      return SessionInfoStatus.SESSION_INFO_STATUS_KEY_NOT_ON_WHITELIST;
    case -1:
    case "UNRECOGNIZED":
    default:
      return SessionInfoStatus.UNRECOGNIZED;
  }
}

export function sessionInfoStatusToJSON(object: SessionInfoStatus): string {
  switch (object) {
    case SessionInfoStatus.SESSION_INFO_STATUS_OK:
      return "SESSION_INFO_STATUS_OK";
    case SessionInfoStatus.SESSION_INFO_STATUS_KEY_NOT_ON_WHITELIST:
      return "SESSION_INFO_STATUS_KEY_NOT_ON_WHITELIST";
    case SessionInfoStatus.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export interface KeyIdentity {
  publicKey?: Uint8Array | undefined;
  handle?: number | undefined;
}

export interface AESGCMPersonalizedSignatureData {
  epoch: Uint8Array;
  nonce: Uint8Array;
  counter: number;
  expiresAt: number;
  tag: Uint8Array;
}

export interface AESGCMResponseSignatureData {
  nonce: Uint8Array;
  counter: number;
  tag: Uint8Array;
}

export interface HMACSignatureData {
  tag: Uint8Array;
}

export interface HMACPersonalizedSignatureData {
  epoch: Uint8Array;
  counter: number;
  expiresAt: number;
  tag: Uint8Array;
}

export interface SignatureData {
  signerIdentity: KeyIdentity | undefined;
  AESGCMPersonalizedData?: AESGCMPersonalizedSignatureData | undefined;
  sessionInfoTag?: HMACSignatureData | undefined;
  HMACPersonalizedData?: HMACPersonalizedSignatureData | undefined;
  AESGCMResponseData?: AESGCMResponseSignatureData | undefined;
}

export interface GetSessionInfoRequest {
  keyIdentity: KeyIdentity | undefined;
}

export interface SessionInfo {
  counter: number;
  publicKey: Uint8Array;
  epoch: Uint8Array;
  clockTime: number;
  status: SessionInfoStatus;
  handle: number;
}

function createBaseKeyIdentity(): KeyIdentity {
  return { publicKey: undefined, handle: undefined };
}

export const KeyIdentity: MessageFns<KeyIdentity> = {
  encode(message: KeyIdentity, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.publicKey !== undefined) {
      writer.uint32(10).bytes(message.publicKey);
    }
    if (message.handle !== undefined) {
      writer.uint32(24).uint32(message.handle);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): KeyIdentity {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseKeyIdentity();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.publicKey = reader.bytes();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.handle = reader.uint32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): KeyIdentity {
    return {
      publicKey: isSet(object.publicKey) ? bytesFromBase64(object.publicKey) : undefined,
      handle: isSet(object.handle) ? globalThis.Number(object.handle) : undefined,
    };
  },

  toJSON(message: KeyIdentity): unknown {
    const obj: any = {};
    if (message.publicKey !== undefined) {
      obj.publicKey = base64FromBytes(message.publicKey);
    }
    if (message.handle !== undefined) {
      obj.handle = Math.round(message.handle);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<KeyIdentity>, I>>(base?: I): KeyIdentity {
    return KeyIdentity.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<KeyIdentity>, I>>(object: I): KeyIdentity {
    const message = createBaseKeyIdentity();
    message.publicKey = object.publicKey ?? undefined;
    message.handle = object.handle ?? undefined;
    return message;
  },
};

function createBaseAESGCMPersonalizedSignatureData(): AESGCMPersonalizedSignatureData {
  return { epoch: new Uint8Array(0), nonce: new Uint8Array(0), counter: 0, expiresAt: 0, tag: new Uint8Array(0) };
}

export const AESGCMPersonalizedSignatureData: MessageFns<AESGCMPersonalizedSignatureData> = {
  encode(message: AESGCMPersonalizedSignatureData, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.epoch.length !== 0) {
      writer.uint32(10).bytes(message.epoch);
    }
    if (message.nonce.length !== 0) {
      writer.uint32(18).bytes(message.nonce);
    }
    if (message.counter !== 0) {
      writer.uint32(24).uint32(message.counter);
    }
    if (message.expiresAt !== 0) {
      writer.uint32(37).fixed32(message.expiresAt);
    }
    if (message.tag.length !== 0) {
      writer.uint32(42).bytes(message.tag);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AESGCMPersonalizedSignatureData {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAESGCMPersonalizedSignatureData();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.epoch = reader.bytes();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.nonce = reader.bytes();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.counter = reader.uint32();
          continue;
        }
        case 4: {
          if (tag !== 37) {
            break;
          }

          message.expiresAt = reader.fixed32();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.tag = reader.bytes();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AESGCMPersonalizedSignatureData {
    return {
      epoch: isSet(object.epoch) ? bytesFromBase64(object.epoch) : new Uint8Array(0),
      nonce: isSet(object.nonce) ? bytesFromBase64(object.nonce) : new Uint8Array(0),
      counter: isSet(object.counter) ? globalThis.Number(object.counter) : 0,
      expiresAt: isSet(object.expiresAt) ? globalThis.Number(object.expiresAt) : 0,
      tag: isSet(object.tag) ? bytesFromBase64(object.tag) : new Uint8Array(0),
    };
  },

  toJSON(message: AESGCMPersonalizedSignatureData): unknown {
    const obj: any = {};
    if (message.epoch.length !== 0) {
      obj.epoch = base64FromBytes(message.epoch);
    }
    if (message.nonce.length !== 0) {
      obj.nonce = base64FromBytes(message.nonce);
    }
    if (message.counter !== 0) {
      obj.counter = Math.round(message.counter);
    }
    if (message.expiresAt !== 0) {
      obj.expiresAt = Math.round(message.expiresAt);
    }
    if (message.tag.length !== 0) {
      obj.tag = base64FromBytes(message.tag);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AESGCMPersonalizedSignatureData>, I>>(base?: I): AESGCMPersonalizedSignatureData {
    return AESGCMPersonalizedSignatureData.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AESGCMPersonalizedSignatureData>, I>>(
    object: I,
  ): AESGCMPersonalizedSignatureData {
    const message = createBaseAESGCMPersonalizedSignatureData();
    message.epoch = object.epoch ?? new Uint8Array(0);
    message.nonce = object.nonce ?? new Uint8Array(0);
    message.counter = object.counter ?? 0;
    message.expiresAt = object.expiresAt ?? 0;
    message.tag = object.tag ?? new Uint8Array(0);
    return message;
  },
};

function createBaseAESGCMResponseSignatureData(): AESGCMResponseSignatureData {
  return { nonce: new Uint8Array(0), counter: 0, tag: new Uint8Array(0) };
}

export const AESGCMResponseSignatureData: MessageFns<AESGCMResponseSignatureData> = {
  encode(message: AESGCMResponseSignatureData, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.nonce.length !== 0) {
      writer.uint32(10).bytes(message.nonce);
    }
    if (message.counter !== 0) {
      writer.uint32(16).uint32(message.counter);
    }
    if (message.tag.length !== 0) {
      writer.uint32(26).bytes(message.tag);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AESGCMResponseSignatureData {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAESGCMResponseSignatureData();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.nonce = reader.bytes();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.counter = reader.uint32();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.tag = reader.bytes();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AESGCMResponseSignatureData {
    return {
      nonce: isSet(object.nonce) ? bytesFromBase64(object.nonce) : new Uint8Array(0),
      counter: isSet(object.counter) ? globalThis.Number(object.counter) : 0,
      tag: isSet(object.tag) ? bytesFromBase64(object.tag) : new Uint8Array(0),
    };
  },

  toJSON(message: AESGCMResponseSignatureData): unknown {
    const obj: any = {};
    if (message.nonce.length !== 0) {
      obj.nonce = base64FromBytes(message.nonce);
    }
    if (message.counter !== 0) {
      obj.counter = Math.round(message.counter);
    }
    if (message.tag.length !== 0) {
      obj.tag = base64FromBytes(message.tag);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AESGCMResponseSignatureData>, I>>(base?: I): AESGCMResponseSignatureData {
    return AESGCMResponseSignatureData.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AESGCMResponseSignatureData>, I>>(object: I): AESGCMResponseSignatureData {
    const message = createBaseAESGCMResponseSignatureData();
    message.nonce = object.nonce ?? new Uint8Array(0);
    message.counter = object.counter ?? 0;
    message.tag = object.tag ?? new Uint8Array(0);
    return message;
  },
};

function createBaseHMACSignatureData(): HMACSignatureData {
  return { tag: new Uint8Array(0) };
}

export const HMACSignatureData: MessageFns<HMACSignatureData> = {
  encode(message: HMACSignatureData, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.tag.length !== 0) {
      writer.uint32(10).bytes(message.tag);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): HMACSignatureData {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseHMACSignatureData();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.tag = reader.bytes();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): HMACSignatureData {
    return { tag: isSet(object.tag) ? bytesFromBase64(object.tag) : new Uint8Array(0) };
  },

  toJSON(message: HMACSignatureData): unknown {
    const obj: any = {};
    if (message.tag.length !== 0) {
      obj.tag = base64FromBytes(message.tag);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<HMACSignatureData>, I>>(base?: I): HMACSignatureData {
    return HMACSignatureData.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<HMACSignatureData>, I>>(object: I): HMACSignatureData {
    const message = createBaseHMACSignatureData();
    message.tag = object.tag ?? new Uint8Array(0);
    return message;
  },
};

function createBaseHMACPersonalizedSignatureData(): HMACPersonalizedSignatureData {
  return { epoch: new Uint8Array(0), counter: 0, expiresAt: 0, tag: new Uint8Array(0) };
}

export const HMACPersonalizedSignatureData: MessageFns<HMACPersonalizedSignatureData> = {
  encode(message: HMACPersonalizedSignatureData, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.epoch.length !== 0) {
      writer.uint32(10).bytes(message.epoch);
    }
    if (message.counter !== 0) {
      writer.uint32(16).uint32(message.counter);
    }
    if (message.expiresAt !== 0) {
      writer.uint32(29).fixed32(message.expiresAt);
    }
    if (message.tag.length !== 0) {
      writer.uint32(34).bytes(message.tag);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): HMACPersonalizedSignatureData {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseHMACPersonalizedSignatureData();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.epoch = reader.bytes();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.counter = reader.uint32();
          continue;
        }
        case 3: {
          if (tag !== 29) {
            break;
          }

          message.expiresAt = reader.fixed32();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.tag = reader.bytes();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): HMACPersonalizedSignatureData {
    return {
      epoch: isSet(object.epoch) ? bytesFromBase64(object.epoch) : new Uint8Array(0),
      counter: isSet(object.counter) ? globalThis.Number(object.counter) : 0,
      expiresAt: isSet(object.expiresAt) ? globalThis.Number(object.expiresAt) : 0,
      tag: isSet(object.tag) ? bytesFromBase64(object.tag) : new Uint8Array(0),
    };
  },

  toJSON(message: HMACPersonalizedSignatureData): unknown {
    const obj: any = {};
    if (message.epoch.length !== 0) {
      obj.epoch = base64FromBytes(message.epoch);
    }
    if (message.counter !== 0) {
      obj.counter = Math.round(message.counter);
    }
    if (message.expiresAt !== 0) {
      obj.expiresAt = Math.round(message.expiresAt);
    }
    if (message.tag.length !== 0) {
      obj.tag = base64FromBytes(message.tag);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<HMACPersonalizedSignatureData>, I>>(base?: I): HMACPersonalizedSignatureData {
    return HMACPersonalizedSignatureData.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<HMACPersonalizedSignatureData>, I>>(
    object: I,
  ): HMACPersonalizedSignatureData {
    const message = createBaseHMACPersonalizedSignatureData();
    message.epoch = object.epoch ?? new Uint8Array(0);
    message.counter = object.counter ?? 0;
    message.expiresAt = object.expiresAt ?? 0;
    message.tag = object.tag ?? new Uint8Array(0);
    return message;
  },
};

function createBaseSignatureData(): SignatureData {
  return {
    signerIdentity: undefined,
    AESGCMPersonalizedData: undefined,
    sessionInfoTag: undefined,
    HMACPersonalizedData: undefined,
    AESGCMResponseData: undefined,
  };
}

export const SignatureData: MessageFns<SignatureData> = {
  encode(message: SignatureData, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.signerIdentity !== undefined) {
      KeyIdentity.encode(message.signerIdentity, writer.uint32(10).fork()).join();
    }
    if (message.AESGCMPersonalizedData !== undefined) {
      AESGCMPersonalizedSignatureData.encode(message.AESGCMPersonalizedData, writer.uint32(42).fork()).join();
    }
    if (message.sessionInfoTag !== undefined) {
      HMACSignatureData.encode(message.sessionInfoTag, writer.uint32(50).fork()).join();
    }
    if (message.HMACPersonalizedData !== undefined) {
      HMACPersonalizedSignatureData.encode(message.HMACPersonalizedData, writer.uint32(66).fork()).join();
    }
    if (message.AESGCMResponseData !== undefined) {
      AESGCMResponseSignatureData.encode(message.AESGCMResponseData, writer.uint32(74).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SignatureData {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSignatureData();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.signerIdentity = KeyIdentity.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.AESGCMPersonalizedData = AESGCMPersonalizedSignatureData.decode(reader, reader.uint32());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.sessionInfoTag = HMACSignatureData.decode(reader, reader.uint32());
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.HMACPersonalizedData = HMACPersonalizedSignatureData.decode(reader, reader.uint32());
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.AESGCMResponseData = AESGCMResponseSignatureData.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SignatureData {
    return {
      signerIdentity: isSet(object.signerIdentity) ? KeyIdentity.fromJSON(object.signerIdentity) : undefined,
      AESGCMPersonalizedData: isSet(object.AESGCMPersonalizedData)
        ? AESGCMPersonalizedSignatureData.fromJSON(object.AESGCMPersonalizedData)
        : undefined,
      sessionInfoTag: isSet(object.sessionInfoTag) ? HMACSignatureData.fromJSON(object.sessionInfoTag) : undefined,
      HMACPersonalizedData: isSet(object.HMACPersonalizedData)
        ? HMACPersonalizedSignatureData.fromJSON(object.HMACPersonalizedData)
        : undefined,
      AESGCMResponseData: isSet(object.AESGCMResponseData)
        ? AESGCMResponseSignatureData.fromJSON(object.AESGCMResponseData)
        : undefined,
    };
  },

  toJSON(message: SignatureData): unknown {
    const obj: any = {};
    if (message.signerIdentity !== undefined) {
      obj.signerIdentity = KeyIdentity.toJSON(message.signerIdentity);
    }
    if (message.AESGCMPersonalizedData !== undefined) {
      obj.AESGCMPersonalizedData = AESGCMPersonalizedSignatureData.toJSON(message.AESGCMPersonalizedData);
    }
    if (message.sessionInfoTag !== undefined) {
      obj.sessionInfoTag = HMACSignatureData.toJSON(message.sessionInfoTag);
    }
    if (message.HMACPersonalizedData !== undefined) {
      obj.HMACPersonalizedData = HMACPersonalizedSignatureData.toJSON(message.HMACPersonalizedData);
    }
    if (message.AESGCMResponseData !== undefined) {
      obj.AESGCMResponseData = AESGCMResponseSignatureData.toJSON(message.AESGCMResponseData);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SignatureData>, I>>(base?: I): SignatureData {
    return SignatureData.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SignatureData>, I>>(object: I): SignatureData {
    const message = createBaseSignatureData();
    message.signerIdentity = (object.signerIdentity !== undefined && object.signerIdentity !== null)
      ? KeyIdentity.fromPartial(object.signerIdentity)
      : undefined;
    message.AESGCMPersonalizedData =
      (object.AESGCMPersonalizedData !== undefined && object.AESGCMPersonalizedData !== null)
        ? AESGCMPersonalizedSignatureData.fromPartial(object.AESGCMPersonalizedData)
        : undefined;
    message.sessionInfoTag = (object.sessionInfoTag !== undefined && object.sessionInfoTag !== null)
      ? HMACSignatureData.fromPartial(object.sessionInfoTag)
      : undefined;
    message.HMACPersonalizedData = (object.HMACPersonalizedData !== undefined && object.HMACPersonalizedData !== null)
      ? HMACPersonalizedSignatureData.fromPartial(object.HMACPersonalizedData)
      : undefined;
    message.AESGCMResponseData = (object.AESGCMResponseData !== undefined && object.AESGCMResponseData !== null)
      ? AESGCMResponseSignatureData.fromPartial(object.AESGCMResponseData)
      : undefined;
    return message;
  },
};

function createBaseGetSessionInfoRequest(): GetSessionInfoRequest {
  return { keyIdentity: undefined };
}

export const GetSessionInfoRequest: MessageFns<GetSessionInfoRequest> = {
  encode(message: GetSessionInfoRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.keyIdentity !== undefined) {
      KeyIdentity.encode(message.keyIdentity, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetSessionInfoRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetSessionInfoRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.keyIdentity = KeyIdentity.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetSessionInfoRequest {
    return { keyIdentity: isSet(object.keyIdentity) ? KeyIdentity.fromJSON(object.keyIdentity) : undefined };
  },

  toJSON(message: GetSessionInfoRequest): unknown {
    const obj: any = {};
    if (message.keyIdentity !== undefined) {
      obj.keyIdentity = KeyIdentity.toJSON(message.keyIdentity);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetSessionInfoRequest>, I>>(base?: I): GetSessionInfoRequest {
    return GetSessionInfoRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetSessionInfoRequest>, I>>(object: I): GetSessionInfoRequest {
    const message = createBaseGetSessionInfoRequest();
    message.keyIdentity = (object.keyIdentity !== undefined && object.keyIdentity !== null)
      ? KeyIdentity.fromPartial(object.keyIdentity)
      : undefined;
    return message;
  },
};

function createBaseSessionInfo(): SessionInfo {
  return { counter: 0, publicKey: new Uint8Array(0), epoch: new Uint8Array(0), clockTime: 0, status: 0, handle: 0 };
}

export const SessionInfo: MessageFns<SessionInfo> = {
  encode(message: SessionInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.counter !== 0) {
      writer.uint32(8).uint32(message.counter);
    }
    if (message.publicKey.length !== 0) {
      writer.uint32(18).bytes(message.publicKey);
    }
    if (message.epoch.length !== 0) {
      writer.uint32(26).bytes(message.epoch);
    }
    if (message.clockTime !== 0) {
      writer.uint32(37).fixed32(message.clockTime);
    }
    if (message.status !== 0) {
      writer.uint32(40).int32(message.status);
    }
    if (message.handle !== 0) {
      writer.uint32(48).uint32(message.handle);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SessionInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSessionInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.counter = reader.uint32();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.publicKey = reader.bytes();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.epoch = reader.bytes();
          continue;
        }
        case 4: {
          if (tag !== 37) {
            break;
          }

          message.clockTime = reader.fixed32();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.status = reader.int32() as any;
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.handle = reader.uint32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SessionInfo {
    return {
      counter: isSet(object.counter) ? globalThis.Number(object.counter) : 0,
      publicKey: isSet(object.publicKey) ? bytesFromBase64(object.publicKey) : new Uint8Array(0),
      epoch: isSet(object.epoch) ? bytesFromBase64(object.epoch) : new Uint8Array(0),
      clockTime: isSet(object.clockTime) ? globalThis.Number(object.clockTime) : 0,
      status: isSet(object.status) ? sessionInfoStatusFromJSON(object.status) : 0,
      handle: isSet(object.handle) ? globalThis.Number(object.handle) : 0,
    };
  },

  toJSON(message: SessionInfo): unknown {
    const obj: any = {};
    if (message.counter !== 0) {
      obj.counter = Math.round(message.counter);
    }
    if (message.publicKey.length !== 0) {
      obj.publicKey = base64FromBytes(message.publicKey);
    }
    if (message.epoch.length !== 0) {
      obj.epoch = base64FromBytes(message.epoch);
    }
    if (message.clockTime !== 0) {
      obj.clockTime = Math.round(message.clockTime);
    }
    if (message.status !== 0) {
      obj.status = sessionInfoStatusToJSON(message.status);
    }
    if (message.handle !== 0) {
      obj.handle = Math.round(message.handle);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SessionInfo>, I>>(base?: I): SessionInfo {
    return SessionInfo.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SessionInfo>, I>>(object: I): SessionInfo {
    const message = createBaseSessionInfo();
    message.counter = object.counter ?? 0;
    message.publicKey = object.publicKey ?? new Uint8Array(0);
    message.epoch = object.epoch ?? new Uint8Array(0);
    message.clockTime = object.clockTime ?? 0;
    message.status = object.status ?? 0;
    message.handle = object.handle ?? 0;
    return message;
  },
};

function bytesFromBase64(b64: string): Uint8Array {
  if ((globalThis as any).Buffer) {
    return Uint8Array.from(globalThis.Buffer.from(b64, "base64"));
  } else {
    const bin = globalThis.atob(b64);
    const arr = new Uint8Array(bin.length);
    for (let i = 0; i < bin.length; ++i) {
      arr[i] = bin.charCodeAt(i);
    }
    return arr;
  }
}

function base64FromBytes(arr: Uint8Array): string {
  if ((globalThis as any).Buffer) {
    return globalThis.Buffer.from(arr).toString("base64");
  } else {
    const bin: string[] = [];
    arr.forEach((byte) => {
      bin.push(globalThis.String.fromCharCode(byte));
    });
    return globalThis.btoa(bin.join(""));
  }
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
