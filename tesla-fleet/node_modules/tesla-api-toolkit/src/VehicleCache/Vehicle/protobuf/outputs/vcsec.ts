// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.6.0
//   protoc               v3.12.4
// source: vcsec.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import { NominalError } from "./errors";
import { Role, roleFromJSON, roleToJSON } from "./keys";

export const protobufPackage = "VCSEC";

export enum SignatureType {
  SIGNATURE_TYPE_NONE = 0,
  SIGNATURE_TYPE_PRESENT_KEY = 2,
  UNRECOGNIZED = -1,
}

export function signatureTypeFromJSON(object: any): SignatureType {
  switch (object) {
    case 0:
    case "SIGNATURE_TYPE_NONE":
      return SignatureType.SIGNATURE_TYPE_NONE;
    case 2:
    case "SIGNATURE_TYPE_PRESENT_KEY":
      return SignatureType.SIGNATURE_TYPE_PRESENT_KEY;
    case -1:
    case "UNRECOGNIZED":
    default:
      return SignatureType.UNRECOGNIZED;
  }
}

export function signatureTypeToJSON(object: SignatureType): string {
  switch (object) {
    case SignatureType.SIGNATURE_TYPE_NONE:
      return "SIGNATURE_TYPE_NONE";
    case SignatureType.SIGNATURE_TYPE_PRESENT_KEY:
      return "SIGNATURE_TYPE_PRESENT_KEY";
    case SignatureType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum KeyFormFactor {
  KEY_FORM_FACTOR_UNKNOWN = 0,
  KEY_FORM_FACTOR_NFC_CARD = 1,
  KEY_FORM_FACTOR_IOS_DEVICE = 6,
  KEY_FORM_FACTOR_ANDROID_DEVICE = 7,
  KEY_FORM_FACTOR_CLOUD_KEY = 9,
  UNRECOGNIZED = -1,
}

export function keyFormFactorFromJSON(object: any): KeyFormFactor {
  switch (object) {
    case 0:
    case "KEY_FORM_FACTOR_UNKNOWN":
      return KeyFormFactor.KEY_FORM_FACTOR_UNKNOWN;
    case 1:
    case "KEY_FORM_FACTOR_NFC_CARD":
      return KeyFormFactor.KEY_FORM_FACTOR_NFC_CARD;
    case 6:
    case "KEY_FORM_FACTOR_IOS_DEVICE":
      return KeyFormFactor.KEY_FORM_FACTOR_IOS_DEVICE;
    case 7:
    case "KEY_FORM_FACTOR_ANDROID_DEVICE":
      return KeyFormFactor.KEY_FORM_FACTOR_ANDROID_DEVICE;
    case 9:
    case "KEY_FORM_FACTOR_CLOUD_KEY":
      return KeyFormFactor.KEY_FORM_FACTOR_CLOUD_KEY;
    case -1:
    case "UNRECOGNIZED":
    default:
      return KeyFormFactor.UNRECOGNIZED;
  }
}

export function keyFormFactorToJSON(object: KeyFormFactor): string {
  switch (object) {
    case KeyFormFactor.KEY_FORM_FACTOR_UNKNOWN:
      return "KEY_FORM_FACTOR_UNKNOWN";
    case KeyFormFactor.KEY_FORM_FACTOR_NFC_CARD:
      return "KEY_FORM_FACTOR_NFC_CARD";
    case KeyFormFactor.KEY_FORM_FACTOR_IOS_DEVICE:
      return "KEY_FORM_FACTOR_IOS_DEVICE";
    case KeyFormFactor.KEY_FORM_FACTOR_ANDROID_DEVICE:
      return "KEY_FORM_FACTOR_ANDROID_DEVICE";
    case KeyFormFactor.KEY_FORM_FACTOR_CLOUD_KEY:
      return "KEY_FORM_FACTOR_CLOUD_KEY";
    case KeyFormFactor.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum InformationRequestType {
  INFORMATION_REQUEST_TYPE_GET_STATUS = 0,
  INFORMATION_REQUEST_TYPE_GET_WHITELIST_INFO = 5,
  INFORMATION_REQUEST_TYPE_GET_WHITELIST_ENTRY_INFO = 6,
  UNRECOGNIZED = -1,
}

export function informationRequestTypeFromJSON(object: any): InformationRequestType {
  switch (object) {
    case 0:
    case "INFORMATION_REQUEST_TYPE_GET_STATUS":
      return InformationRequestType.INFORMATION_REQUEST_TYPE_GET_STATUS;
    case 5:
    case "INFORMATION_REQUEST_TYPE_GET_WHITELIST_INFO":
      return InformationRequestType.INFORMATION_REQUEST_TYPE_GET_WHITELIST_INFO;
    case 6:
    case "INFORMATION_REQUEST_TYPE_GET_WHITELIST_ENTRY_INFO":
      return InformationRequestType.INFORMATION_REQUEST_TYPE_GET_WHITELIST_ENTRY_INFO;
    case -1:
    case "UNRECOGNIZED":
    default:
      return InformationRequestType.UNRECOGNIZED;
  }
}

export function informationRequestTypeToJSON(object: InformationRequestType): string {
  switch (object) {
    case InformationRequestType.INFORMATION_REQUEST_TYPE_GET_STATUS:
      return "INFORMATION_REQUEST_TYPE_GET_STATUS";
    case InformationRequestType.INFORMATION_REQUEST_TYPE_GET_WHITELIST_INFO:
      return "INFORMATION_REQUEST_TYPE_GET_WHITELIST_INFO";
    case InformationRequestType.INFORMATION_REQUEST_TYPE_GET_WHITELIST_ENTRY_INFO:
      return "INFORMATION_REQUEST_TYPE_GET_WHITELIST_ENTRY_INFO";
    case InformationRequestType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum RKEActionE {
  RKE_ACTION_UNLOCK = 0,
  RKE_ACTION_LOCK = 1,
  RKE_ACTION_REMOTE_DRIVE = 20,
  RKE_ACTION_AUTO_SECURE_VEHICLE = 29,
  RKE_ACTION_WAKE_VEHICLE = 30,
  UNRECOGNIZED = -1,
}

export function rKEActionEFromJSON(object: any): RKEActionE {
  switch (object) {
    case 0:
    case "RKE_ACTION_UNLOCK":
      return RKEActionE.RKE_ACTION_UNLOCK;
    case 1:
    case "RKE_ACTION_LOCK":
      return RKEActionE.RKE_ACTION_LOCK;
    case 20:
    case "RKE_ACTION_REMOTE_DRIVE":
      return RKEActionE.RKE_ACTION_REMOTE_DRIVE;
    case 29:
    case "RKE_ACTION_AUTO_SECURE_VEHICLE":
      return RKEActionE.RKE_ACTION_AUTO_SECURE_VEHICLE;
    case 30:
    case "RKE_ACTION_WAKE_VEHICLE":
      return RKEActionE.RKE_ACTION_WAKE_VEHICLE;
    case -1:
    case "UNRECOGNIZED":
    default:
      return RKEActionE.UNRECOGNIZED;
  }
}

export function rKEActionEToJSON(object: RKEActionE): string {
  switch (object) {
    case RKEActionE.RKE_ACTION_UNLOCK:
      return "RKE_ACTION_UNLOCK";
    case RKEActionE.RKE_ACTION_LOCK:
      return "RKE_ACTION_LOCK";
    case RKEActionE.RKE_ACTION_REMOTE_DRIVE:
      return "RKE_ACTION_REMOTE_DRIVE";
    case RKEActionE.RKE_ACTION_AUTO_SECURE_VEHICLE:
      return "RKE_ACTION_AUTO_SECURE_VEHICLE";
    case RKEActionE.RKE_ACTION_WAKE_VEHICLE:
      return "RKE_ACTION_WAKE_VEHICLE";
    case RKEActionE.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum ClosureMoveTypeE {
  CLOSURE_MOVE_TYPE_NONE = 0,
  CLOSURE_MOVE_TYPE_MOVE = 1,
  CLOSURE_MOVE_TYPE_STOP = 2,
  CLOSURE_MOVE_TYPE_OPEN = 3,
  CLOSURE_MOVE_TYPE_CLOSE = 4,
  UNRECOGNIZED = -1,
}

export function closureMoveTypeEFromJSON(object: any): ClosureMoveTypeE {
  switch (object) {
    case 0:
    case "CLOSURE_MOVE_TYPE_NONE":
      return ClosureMoveTypeE.CLOSURE_MOVE_TYPE_NONE;
    case 1:
    case "CLOSURE_MOVE_TYPE_MOVE":
      return ClosureMoveTypeE.CLOSURE_MOVE_TYPE_MOVE;
    case 2:
    case "CLOSURE_MOVE_TYPE_STOP":
      return ClosureMoveTypeE.CLOSURE_MOVE_TYPE_STOP;
    case 3:
    case "CLOSURE_MOVE_TYPE_OPEN":
      return ClosureMoveTypeE.CLOSURE_MOVE_TYPE_OPEN;
    case 4:
    case "CLOSURE_MOVE_TYPE_CLOSE":
      return ClosureMoveTypeE.CLOSURE_MOVE_TYPE_CLOSE;
    case -1:
    case "UNRECOGNIZED":
    default:
      return ClosureMoveTypeE.UNRECOGNIZED;
  }
}

export function closureMoveTypeEToJSON(object: ClosureMoveTypeE): string {
  switch (object) {
    case ClosureMoveTypeE.CLOSURE_MOVE_TYPE_NONE:
      return "CLOSURE_MOVE_TYPE_NONE";
    case ClosureMoveTypeE.CLOSURE_MOVE_TYPE_MOVE:
      return "CLOSURE_MOVE_TYPE_MOVE";
    case ClosureMoveTypeE.CLOSURE_MOVE_TYPE_STOP:
      return "CLOSURE_MOVE_TYPE_STOP";
    case ClosureMoveTypeE.CLOSURE_MOVE_TYPE_OPEN:
      return "CLOSURE_MOVE_TYPE_OPEN";
    case ClosureMoveTypeE.CLOSURE_MOVE_TYPE_CLOSE:
      return "CLOSURE_MOVE_TYPE_CLOSE";
    case ClosureMoveTypeE.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum OperationStatusE {
  OPERATIONSTATUS_OK = 0,
  OPERATIONSTATUS_WAIT = 1,
  OPERATIONSTATUS_ERROR = 2,
  UNRECOGNIZED = -1,
}

export function operationStatusEFromJSON(object: any): OperationStatusE {
  switch (object) {
    case 0:
    case "OPERATIONSTATUS_OK":
      return OperationStatusE.OPERATIONSTATUS_OK;
    case 1:
    case "OPERATIONSTATUS_WAIT":
      return OperationStatusE.OPERATIONSTATUS_WAIT;
    case 2:
    case "OPERATIONSTATUS_ERROR":
      return OperationStatusE.OPERATIONSTATUS_ERROR;
    case -1:
    case "UNRECOGNIZED":
    default:
      return OperationStatusE.UNRECOGNIZED;
  }
}

export function operationStatusEToJSON(object: OperationStatusE): string {
  switch (object) {
    case OperationStatusE.OPERATIONSTATUS_OK:
      return "OPERATIONSTATUS_OK";
    case OperationStatusE.OPERATIONSTATUS_WAIT:
      return "OPERATIONSTATUS_WAIT";
    case OperationStatusE.OPERATIONSTATUS_ERROR:
      return "OPERATIONSTATUS_ERROR";
    case OperationStatusE.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum SignedMessageInformationE {
  SIGNEDMESSAGE_INFORMATION_NONE = 0,
  SIGNEDMESSAGE_INFORMATION_FAULT_UNKNOWN = 1,
  SIGNEDMESSAGE_INFORMATION_FAULT_NOT_ON_WHITELIST = 2,
  SIGNEDMESSAGE_INFORMATION_FAULT_IV_SMALLER_THAN_EXPECTED = 3,
  SIGNEDMESSAGE_INFORMATION_FAULT_INVALID_TOKEN = 4,
  SIGNEDMESSAGE_INFORMATION_FAULT_TOKEN_AND_COUNTER_INVALID = 5,
  SIGNEDMESSAGE_INFORMATION_FAULT_AES_DECRYPT_AUTH = 6,
  SIGNEDMESSAGE_INFORMATION_FAULT_ECDSA_INPUT = 7,
  SIGNEDMESSAGE_INFORMATION_FAULT_ECDSA_SIGNATURE = 8,
  SIGNEDMESSAGE_INFORMATION_FAULT_LOCAL_ENTITY_START = 9,
  SIGNEDMESSAGE_INFORMATION_FAULT_LOCAL_ENTITY_RESULT = 10,
  SIGNEDMESSAGE_INFORMATION_FAULT_COULD_NOT_RETRIEVE_KEY = 11,
  SIGNEDMESSAGE_INFORMATION_FAULT_COULD_NOT_RETRIEVE_TOKEN = 12,
  SIGNEDMESSAGE_INFORMATION_FAULT_SIGNATURE_TOO_SHORT = 13,
  SIGNEDMESSAGE_INFORMATION_FAULT_TOKEN_IS_INCORRECT_LENGTH = 14,
  SIGNEDMESSAGE_INFORMATION_FAULT_INCORRECT_EPOCH = 15,
  SIGNEDMESSAGE_INFORMATION_FAULT_IV_INCORRECT_LENGTH = 16,
  SIGNEDMESSAGE_INFORMATION_FAULT_TIME_EXPIRED = 17,
  SIGNEDMESSAGE_INFORMATION_FAULT_NOT_PROVISIONED_WITH_IDENTITY = 18,
  SIGNEDMESSAGE_INFORMATION_FAULT_COULD_NOT_HASH_METADATA = 19,
  UNRECOGNIZED = -1,
}

export function signedMessageInformationEFromJSON(object: any): SignedMessageInformationE {
  switch (object) {
    case 0:
    case "SIGNEDMESSAGE_INFORMATION_NONE":
      return SignedMessageInformationE.SIGNEDMESSAGE_INFORMATION_NONE;
    case 1:
    case "SIGNEDMESSAGE_INFORMATION_FAULT_UNKNOWN":
      return SignedMessageInformationE.SIGNEDMESSAGE_INFORMATION_FAULT_UNKNOWN;
    case 2:
    case "SIGNEDMESSAGE_INFORMATION_FAULT_NOT_ON_WHITELIST":
      return SignedMessageInformationE.SIGNEDMESSAGE_INFORMATION_FAULT_NOT_ON_WHITELIST;
    case 3:
    case "SIGNEDMESSAGE_INFORMATION_FAULT_IV_SMALLER_THAN_EXPECTED":
      return SignedMessageInformationE.SIGNEDMESSAGE_INFORMATION_FAULT_IV_SMALLER_THAN_EXPECTED;
    case 4:
    case "SIGNEDMESSAGE_INFORMATION_FAULT_INVALID_TOKEN":
      return SignedMessageInformationE.SIGNEDMESSAGE_INFORMATION_FAULT_INVALID_TOKEN;
    case 5:
    case "SIGNEDMESSAGE_INFORMATION_FAULT_TOKEN_AND_COUNTER_INVALID":
      return SignedMessageInformationE.SIGNEDMESSAGE_INFORMATION_FAULT_TOKEN_AND_COUNTER_INVALID;
    case 6:
    case "SIGNEDMESSAGE_INFORMATION_FAULT_AES_DECRYPT_AUTH":
      return SignedMessageInformationE.SIGNEDMESSAGE_INFORMATION_FAULT_AES_DECRYPT_AUTH;
    case 7:
    case "SIGNEDMESSAGE_INFORMATION_FAULT_ECDSA_INPUT":
      return SignedMessageInformationE.SIGNEDMESSAGE_INFORMATION_FAULT_ECDSA_INPUT;
    case 8:
    case "SIGNEDMESSAGE_INFORMATION_FAULT_ECDSA_SIGNATURE":
      return SignedMessageInformationE.SIGNEDMESSAGE_INFORMATION_FAULT_ECDSA_SIGNATURE;
    case 9:
    case "SIGNEDMESSAGE_INFORMATION_FAULT_LOCAL_ENTITY_START":
      return SignedMessageInformationE.SIGNEDMESSAGE_INFORMATION_FAULT_LOCAL_ENTITY_START;
    case 10:
    case "SIGNEDMESSAGE_INFORMATION_FAULT_LOCAL_ENTITY_RESULT":
      return SignedMessageInformationE.SIGNEDMESSAGE_INFORMATION_FAULT_LOCAL_ENTITY_RESULT;
    case 11:
    case "SIGNEDMESSAGE_INFORMATION_FAULT_COULD_NOT_RETRIEVE_KEY":
      return SignedMessageInformationE.SIGNEDMESSAGE_INFORMATION_FAULT_COULD_NOT_RETRIEVE_KEY;
    case 12:
    case "SIGNEDMESSAGE_INFORMATION_FAULT_COULD_NOT_RETRIEVE_TOKEN":
      return SignedMessageInformationE.SIGNEDMESSAGE_INFORMATION_FAULT_COULD_NOT_RETRIEVE_TOKEN;
    case 13:
    case "SIGNEDMESSAGE_INFORMATION_FAULT_SIGNATURE_TOO_SHORT":
      return SignedMessageInformationE.SIGNEDMESSAGE_INFORMATION_FAULT_SIGNATURE_TOO_SHORT;
    case 14:
    case "SIGNEDMESSAGE_INFORMATION_FAULT_TOKEN_IS_INCORRECT_LENGTH":
      return SignedMessageInformationE.SIGNEDMESSAGE_INFORMATION_FAULT_TOKEN_IS_INCORRECT_LENGTH;
    case 15:
    case "SIGNEDMESSAGE_INFORMATION_FAULT_INCORRECT_EPOCH":
      return SignedMessageInformationE.SIGNEDMESSAGE_INFORMATION_FAULT_INCORRECT_EPOCH;
    case 16:
    case "SIGNEDMESSAGE_INFORMATION_FAULT_IV_INCORRECT_LENGTH":
      return SignedMessageInformationE.SIGNEDMESSAGE_INFORMATION_FAULT_IV_INCORRECT_LENGTH;
    case 17:
    case "SIGNEDMESSAGE_INFORMATION_FAULT_TIME_EXPIRED":
      return SignedMessageInformationE.SIGNEDMESSAGE_INFORMATION_FAULT_TIME_EXPIRED;
    case 18:
    case "SIGNEDMESSAGE_INFORMATION_FAULT_NOT_PROVISIONED_WITH_IDENTITY":
      return SignedMessageInformationE.SIGNEDMESSAGE_INFORMATION_FAULT_NOT_PROVISIONED_WITH_IDENTITY;
    case 19:
    case "SIGNEDMESSAGE_INFORMATION_FAULT_COULD_NOT_HASH_METADATA":
      return SignedMessageInformationE.SIGNEDMESSAGE_INFORMATION_FAULT_COULD_NOT_HASH_METADATA;
    case -1:
    case "UNRECOGNIZED":
    default:
      return SignedMessageInformationE.UNRECOGNIZED;
  }
}

export function signedMessageInformationEToJSON(object: SignedMessageInformationE): string {
  switch (object) {
    case SignedMessageInformationE.SIGNEDMESSAGE_INFORMATION_NONE:
      return "SIGNEDMESSAGE_INFORMATION_NONE";
    case SignedMessageInformationE.SIGNEDMESSAGE_INFORMATION_FAULT_UNKNOWN:
      return "SIGNEDMESSAGE_INFORMATION_FAULT_UNKNOWN";
    case SignedMessageInformationE.SIGNEDMESSAGE_INFORMATION_FAULT_NOT_ON_WHITELIST:
      return "SIGNEDMESSAGE_INFORMATION_FAULT_NOT_ON_WHITELIST";
    case SignedMessageInformationE.SIGNEDMESSAGE_INFORMATION_FAULT_IV_SMALLER_THAN_EXPECTED:
      return "SIGNEDMESSAGE_INFORMATION_FAULT_IV_SMALLER_THAN_EXPECTED";
    case SignedMessageInformationE.SIGNEDMESSAGE_INFORMATION_FAULT_INVALID_TOKEN:
      return "SIGNEDMESSAGE_INFORMATION_FAULT_INVALID_TOKEN";
    case SignedMessageInformationE.SIGNEDMESSAGE_INFORMATION_FAULT_TOKEN_AND_COUNTER_INVALID:
      return "SIGNEDMESSAGE_INFORMATION_FAULT_TOKEN_AND_COUNTER_INVALID";
    case SignedMessageInformationE.SIGNEDMESSAGE_INFORMATION_FAULT_AES_DECRYPT_AUTH:
      return "SIGNEDMESSAGE_INFORMATION_FAULT_AES_DECRYPT_AUTH";
    case SignedMessageInformationE.SIGNEDMESSAGE_INFORMATION_FAULT_ECDSA_INPUT:
      return "SIGNEDMESSAGE_INFORMATION_FAULT_ECDSA_INPUT";
    case SignedMessageInformationE.SIGNEDMESSAGE_INFORMATION_FAULT_ECDSA_SIGNATURE:
      return "SIGNEDMESSAGE_INFORMATION_FAULT_ECDSA_SIGNATURE";
    case SignedMessageInformationE.SIGNEDMESSAGE_INFORMATION_FAULT_LOCAL_ENTITY_START:
      return "SIGNEDMESSAGE_INFORMATION_FAULT_LOCAL_ENTITY_START";
    case SignedMessageInformationE.SIGNEDMESSAGE_INFORMATION_FAULT_LOCAL_ENTITY_RESULT:
      return "SIGNEDMESSAGE_INFORMATION_FAULT_LOCAL_ENTITY_RESULT";
    case SignedMessageInformationE.SIGNEDMESSAGE_INFORMATION_FAULT_COULD_NOT_RETRIEVE_KEY:
      return "SIGNEDMESSAGE_INFORMATION_FAULT_COULD_NOT_RETRIEVE_KEY";
    case SignedMessageInformationE.SIGNEDMESSAGE_INFORMATION_FAULT_COULD_NOT_RETRIEVE_TOKEN:
      return "SIGNEDMESSAGE_INFORMATION_FAULT_COULD_NOT_RETRIEVE_TOKEN";
    case SignedMessageInformationE.SIGNEDMESSAGE_INFORMATION_FAULT_SIGNATURE_TOO_SHORT:
      return "SIGNEDMESSAGE_INFORMATION_FAULT_SIGNATURE_TOO_SHORT";
    case SignedMessageInformationE.SIGNEDMESSAGE_INFORMATION_FAULT_TOKEN_IS_INCORRECT_LENGTH:
      return "SIGNEDMESSAGE_INFORMATION_FAULT_TOKEN_IS_INCORRECT_LENGTH";
    case SignedMessageInformationE.SIGNEDMESSAGE_INFORMATION_FAULT_INCORRECT_EPOCH:
      return "SIGNEDMESSAGE_INFORMATION_FAULT_INCORRECT_EPOCH";
    case SignedMessageInformationE.SIGNEDMESSAGE_INFORMATION_FAULT_IV_INCORRECT_LENGTH:
      return "SIGNEDMESSAGE_INFORMATION_FAULT_IV_INCORRECT_LENGTH";
    case SignedMessageInformationE.SIGNEDMESSAGE_INFORMATION_FAULT_TIME_EXPIRED:
      return "SIGNEDMESSAGE_INFORMATION_FAULT_TIME_EXPIRED";
    case SignedMessageInformationE.SIGNEDMESSAGE_INFORMATION_FAULT_NOT_PROVISIONED_WITH_IDENTITY:
      return "SIGNEDMESSAGE_INFORMATION_FAULT_NOT_PROVISIONED_WITH_IDENTITY";
    case SignedMessageInformationE.SIGNEDMESSAGE_INFORMATION_FAULT_COULD_NOT_HASH_METADATA:
      return "SIGNEDMESSAGE_INFORMATION_FAULT_COULD_NOT_HASH_METADATA";
    case SignedMessageInformationE.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum WhitelistOperationInformationE {
  WHITELISTOPERATION_INFORMATION_NONE = 0,
  WHITELISTOPERATION_INFORMATION_UNDOCUMENTED_ERROR = 1,
  WHITELISTOPERATION_INFORMATION_NO_PERMISSION_TO_REMOVE_ONESELF = 2,
  WHITELISTOPERATION_INFORMATION_KEYFOB_SLOTS_FULL = 3,
  WHITELISTOPERATION_INFORMATION_WHITELIST_FULL = 4,
  WHITELISTOPERATION_INFORMATION_NO_PERMISSION_TO_ADD = 5,
  WHITELISTOPERATION_INFORMATION_INVALID_PUBLIC_KEY = 6,
  WHITELISTOPERATION_INFORMATION_NO_PERMISSION_TO_REMOVE = 7,
  WHITELISTOPERATION_INFORMATION_NO_PERMISSION_TO_CHANGE_PERMISSIONS = 8,
  WHITELISTOPERATION_INFORMATION_ATTEMPTING_TO_ELEVATE_OTHER_ABOVE_ONESELF = 9,
  WHITELISTOPERATION_INFORMATION_ATTEMPTING_TO_DEMOTE_SUPERIOR_TO_ONESELF = 10,
  WHITELISTOPERATION_INFORMATION_ATTEMPTING_TO_REMOVE_OWN_PERMISSIONS = 11,
  WHITELISTOPERATION_INFORMATION_PUBLIC_KEY_NOT_ON_WHITELIST = 12,
  WHITELISTOPERATION_INFORMATION_ATTEMPTING_TO_ADD_KEY_THAT_IS_ALREADY_ON_THE_WHITELIST = 13,
  WHITELISTOPERATION_INFORMATION_NOT_ALLOWED_TO_ADD_UNLESS_ON_READER = 14,
  WHITELISTOPERATION_INFORMATION_FM_MODIFYING_OUTSIDE_OF_F_MODE = 15,
  WHITELISTOPERATION_INFORMATION_FM_ATTEMPTING_TO_ADD_PERMANENT_KEY = 16,
  WHITELISTOPERATION_INFORMATION_FM_ATTEMPTING_TO_REMOVE_PERMANENT_KEY = 17,
  WHITELISTOPERATION_INFORMATION_KEYCHAIN_WHILE_FS_FULL = 18,
  WHITELISTOPERATION_INFORMATION_ATTEMPTING_TO_ADD_KEY_WITHOUT_ROLE = 19,
  WHITELISTOPERATION_INFORMATION_ATTEMPTING_TO_ADD_KEY_WITH_SERVICE_ROLE = 20,
  WHITELISTOPERATION_INFORMATION_NON_SERVICE_KEY_ATTEMPTING_TO_ADD_SERVICE_TECH = 21,
  WHITELISTOPERATION_INFORMATION_SERVICE_KEY_ATTEMPTING_TO_ADD_SERVICE_TECH_OUTSIDE_SERVICE_MODE = 22,
  UNRECOGNIZED = -1,
}

export function whitelistOperationInformationEFromJSON(object: any): WhitelistOperationInformationE {
  switch (object) {
    case 0:
    case "WHITELISTOPERATION_INFORMATION_NONE":
      return WhitelistOperationInformationE.WHITELISTOPERATION_INFORMATION_NONE;
    case 1:
    case "WHITELISTOPERATION_INFORMATION_UNDOCUMENTED_ERROR":
      return WhitelistOperationInformationE.WHITELISTOPERATION_INFORMATION_UNDOCUMENTED_ERROR;
    case 2:
    case "WHITELISTOPERATION_INFORMATION_NO_PERMISSION_TO_REMOVE_ONESELF":
      return WhitelistOperationInformationE.WHITELISTOPERATION_INFORMATION_NO_PERMISSION_TO_REMOVE_ONESELF;
    case 3:
    case "WHITELISTOPERATION_INFORMATION_KEYFOB_SLOTS_FULL":
      return WhitelistOperationInformationE.WHITELISTOPERATION_INFORMATION_KEYFOB_SLOTS_FULL;
    case 4:
    case "WHITELISTOPERATION_INFORMATION_WHITELIST_FULL":
      return WhitelistOperationInformationE.WHITELISTOPERATION_INFORMATION_WHITELIST_FULL;
    case 5:
    case "WHITELISTOPERATION_INFORMATION_NO_PERMISSION_TO_ADD":
      return WhitelistOperationInformationE.WHITELISTOPERATION_INFORMATION_NO_PERMISSION_TO_ADD;
    case 6:
    case "WHITELISTOPERATION_INFORMATION_INVALID_PUBLIC_KEY":
      return WhitelistOperationInformationE.WHITELISTOPERATION_INFORMATION_INVALID_PUBLIC_KEY;
    case 7:
    case "WHITELISTOPERATION_INFORMATION_NO_PERMISSION_TO_REMOVE":
      return WhitelistOperationInformationE.WHITELISTOPERATION_INFORMATION_NO_PERMISSION_TO_REMOVE;
    case 8:
    case "WHITELISTOPERATION_INFORMATION_NO_PERMISSION_TO_CHANGE_PERMISSIONS":
      return WhitelistOperationInformationE.WHITELISTOPERATION_INFORMATION_NO_PERMISSION_TO_CHANGE_PERMISSIONS;
    case 9:
    case "WHITELISTOPERATION_INFORMATION_ATTEMPTING_TO_ELEVATE_OTHER_ABOVE_ONESELF":
      return WhitelistOperationInformationE.WHITELISTOPERATION_INFORMATION_ATTEMPTING_TO_ELEVATE_OTHER_ABOVE_ONESELF;
    case 10:
    case "WHITELISTOPERATION_INFORMATION_ATTEMPTING_TO_DEMOTE_SUPERIOR_TO_ONESELF":
      return WhitelistOperationInformationE.WHITELISTOPERATION_INFORMATION_ATTEMPTING_TO_DEMOTE_SUPERIOR_TO_ONESELF;
    case 11:
    case "WHITELISTOPERATION_INFORMATION_ATTEMPTING_TO_REMOVE_OWN_PERMISSIONS":
      return WhitelistOperationInformationE.WHITELISTOPERATION_INFORMATION_ATTEMPTING_TO_REMOVE_OWN_PERMISSIONS;
    case 12:
    case "WHITELISTOPERATION_INFORMATION_PUBLIC_KEY_NOT_ON_WHITELIST":
      return WhitelistOperationInformationE.WHITELISTOPERATION_INFORMATION_PUBLIC_KEY_NOT_ON_WHITELIST;
    case 13:
    case "WHITELISTOPERATION_INFORMATION_ATTEMPTING_TO_ADD_KEY_THAT_IS_ALREADY_ON_THE_WHITELIST":
      return WhitelistOperationInformationE
        .WHITELISTOPERATION_INFORMATION_ATTEMPTING_TO_ADD_KEY_THAT_IS_ALREADY_ON_THE_WHITELIST;
    case 14:
    case "WHITELISTOPERATION_INFORMATION_NOT_ALLOWED_TO_ADD_UNLESS_ON_READER":
      return WhitelistOperationInformationE.WHITELISTOPERATION_INFORMATION_NOT_ALLOWED_TO_ADD_UNLESS_ON_READER;
    case 15:
    case "WHITELISTOPERATION_INFORMATION_FM_MODIFYING_OUTSIDE_OF_F_MODE":
      return WhitelistOperationInformationE.WHITELISTOPERATION_INFORMATION_FM_MODIFYING_OUTSIDE_OF_F_MODE;
    case 16:
    case "WHITELISTOPERATION_INFORMATION_FM_ATTEMPTING_TO_ADD_PERMANENT_KEY":
      return WhitelistOperationInformationE.WHITELISTOPERATION_INFORMATION_FM_ATTEMPTING_TO_ADD_PERMANENT_KEY;
    case 17:
    case "WHITELISTOPERATION_INFORMATION_FM_ATTEMPTING_TO_REMOVE_PERMANENT_KEY":
      return WhitelistOperationInformationE.WHITELISTOPERATION_INFORMATION_FM_ATTEMPTING_TO_REMOVE_PERMANENT_KEY;
    case 18:
    case "WHITELISTOPERATION_INFORMATION_KEYCHAIN_WHILE_FS_FULL":
      return WhitelistOperationInformationE.WHITELISTOPERATION_INFORMATION_KEYCHAIN_WHILE_FS_FULL;
    case 19:
    case "WHITELISTOPERATION_INFORMATION_ATTEMPTING_TO_ADD_KEY_WITHOUT_ROLE":
      return WhitelistOperationInformationE.WHITELISTOPERATION_INFORMATION_ATTEMPTING_TO_ADD_KEY_WITHOUT_ROLE;
    case 20:
    case "WHITELISTOPERATION_INFORMATION_ATTEMPTING_TO_ADD_KEY_WITH_SERVICE_ROLE":
      return WhitelistOperationInformationE.WHITELISTOPERATION_INFORMATION_ATTEMPTING_TO_ADD_KEY_WITH_SERVICE_ROLE;
    case 21:
    case "WHITELISTOPERATION_INFORMATION_NON_SERVICE_KEY_ATTEMPTING_TO_ADD_SERVICE_TECH":
      return WhitelistOperationInformationE
        .WHITELISTOPERATION_INFORMATION_NON_SERVICE_KEY_ATTEMPTING_TO_ADD_SERVICE_TECH;
    case 22:
    case "WHITELISTOPERATION_INFORMATION_SERVICE_KEY_ATTEMPTING_TO_ADD_SERVICE_TECH_OUTSIDE_SERVICE_MODE":
      return WhitelistOperationInformationE
        .WHITELISTOPERATION_INFORMATION_SERVICE_KEY_ATTEMPTING_TO_ADD_SERVICE_TECH_OUTSIDE_SERVICE_MODE;
    case -1:
    case "UNRECOGNIZED":
    default:
      return WhitelistOperationInformationE.UNRECOGNIZED;
  }
}

export function whitelistOperationInformationEToJSON(object: WhitelistOperationInformationE): string {
  switch (object) {
    case WhitelistOperationInformationE.WHITELISTOPERATION_INFORMATION_NONE:
      return "WHITELISTOPERATION_INFORMATION_NONE";
    case WhitelistOperationInformationE.WHITELISTOPERATION_INFORMATION_UNDOCUMENTED_ERROR:
      return "WHITELISTOPERATION_INFORMATION_UNDOCUMENTED_ERROR";
    case WhitelistOperationInformationE.WHITELISTOPERATION_INFORMATION_NO_PERMISSION_TO_REMOVE_ONESELF:
      return "WHITELISTOPERATION_INFORMATION_NO_PERMISSION_TO_REMOVE_ONESELF";
    case WhitelistOperationInformationE.WHITELISTOPERATION_INFORMATION_KEYFOB_SLOTS_FULL:
      return "WHITELISTOPERATION_INFORMATION_KEYFOB_SLOTS_FULL";
    case WhitelistOperationInformationE.WHITELISTOPERATION_INFORMATION_WHITELIST_FULL:
      return "WHITELISTOPERATION_INFORMATION_WHITELIST_FULL";
    case WhitelistOperationInformationE.WHITELISTOPERATION_INFORMATION_NO_PERMISSION_TO_ADD:
      return "WHITELISTOPERATION_INFORMATION_NO_PERMISSION_TO_ADD";
    case WhitelistOperationInformationE.WHITELISTOPERATION_INFORMATION_INVALID_PUBLIC_KEY:
      return "WHITELISTOPERATION_INFORMATION_INVALID_PUBLIC_KEY";
    case WhitelistOperationInformationE.WHITELISTOPERATION_INFORMATION_NO_PERMISSION_TO_REMOVE:
      return "WHITELISTOPERATION_INFORMATION_NO_PERMISSION_TO_REMOVE";
    case WhitelistOperationInformationE.WHITELISTOPERATION_INFORMATION_NO_PERMISSION_TO_CHANGE_PERMISSIONS:
      return "WHITELISTOPERATION_INFORMATION_NO_PERMISSION_TO_CHANGE_PERMISSIONS";
    case WhitelistOperationInformationE.WHITELISTOPERATION_INFORMATION_ATTEMPTING_TO_ELEVATE_OTHER_ABOVE_ONESELF:
      return "WHITELISTOPERATION_INFORMATION_ATTEMPTING_TO_ELEVATE_OTHER_ABOVE_ONESELF";
    case WhitelistOperationInformationE.WHITELISTOPERATION_INFORMATION_ATTEMPTING_TO_DEMOTE_SUPERIOR_TO_ONESELF:
      return "WHITELISTOPERATION_INFORMATION_ATTEMPTING_TO_DEMOTE_SUPERIOR_TO_ONESELF";
    case WhitelistOperationInformationE.WHITELISTOPERATION_INFORMATION_ATTEMPTING_TO_REMOVE_OWN_PERMISSIONS:
      return "WHITELISTOPERATION_INFORMATION_ATTEMPTING_TO_REMOVE_OWN_PERMISSIONS";
    case WhitelistOperationInformationE.WHITELISTOPERATION_INFORMATION_PUBLIC_KEY_NOT_ON_WHITELIST:
      return "WHITELISTOPERATION_INFORMATION_PUBLIC_KEY_NOT_ON_WHITELIST";
    case WhitelistOperationInformationE
      .WHITELISTOPERATION_INFORMATION_ATTEMPTING_TO_ADD_KEY_THAT_IS_ALREADY_ON_THE_WHITELIST:
      return "WHITELISTOPERATION_INFORMATION_ATTEMPTING_TO_ADD_KEY_THAT_IS_ALREADY_ON_THE_WHITELIST";
    case WhitelistOperationInformationE.WHITELISTOPERATION_INFORMATION_NOT_ALLOWED_TO_ADD_UNLESS_ON_READER:
      return "WHITELISTOPERATION_INFORMATION_NOT_ALLOWED_TO_ADD_UNLESS_ON_READER";
    case WhitelistOperationInformationE.WHITELISTOPERATION_INFORMATION_FM_MODIFYING_OUTSIDE_OF_F_MODE:
      return "WHITELISTOPERATION_INFORMATION_FM_MODIFYING_OUTSIDE_OF_F_MODE";
    case WhitelistOperationInformationE.WHITELISTOPERATION_INFORMATION_FM_ATTEMPTING_TO_ADD_PERMANENT_KEY:
      return "WHITELISTOPERATION_INFORMATION_FM_ATTEMPTING_TO_ADD_PERMANENT_KEY";
    case WhitelistOperationInformationE.WHITELISTOPERATION_INFORMATION_FM_ATTEMPTING_TO_REMOVE_PERMANENT_KEY:
      return "WHITELISTOPERATION_INFORMATION_FM_ATTEMPTING_TO_REMOVE_PERMANENT_KEY";
    case WhitelistOperationInformationE.WHITELISTOPERATION_INFORMATION_KEYCHAIN_WHILE_FS_FULL:
      return "WHITELISTOPERATION_INFORMATION_KEYCHAIN_WHILE_FS_FULL";
    case WhitelistOperationInformationE.WHITELISTOPERATION_INFORMATION_ATTEMPTING_TO_ADD_KEY_WITHOUT_ROLE:
      return "WHITELISTOPERATION_INFORMATION_ATTEMPTING_TO_ADD_KEY_WITHOUT_ROLE";
    case WhitelistOperationInformationE.WHITELISTOPERATION_INFORMATION_ATTEMPTING_TO_ADD_KEY_WITH_SERVICE_ROLE:
      return "WHITELISTOPERATION_INFORMATION_ATTEMPTING_TO_ADD_KEY_WITH_SERVICE_ROLE";
    case WhitelistOperationInformationE.WHITELISTOPERATION_INFORMATION_NON_SERVICE_KEY_ATTEMPTING_TO_ADD_SERVICE_TECH:
      return "WHITELISTOPERATION_INFORMATION_NON_SERVICE_KEY_ATTEMPTING_TO_ADD_SERVICE_TECH";
    case WhitelistOperationInformationE
      .WHITELISTOPERATION_INFORMATION_SERVICE_KEY_ATTEMPTING_TO_ADD_SERVICE_TECH_OUTSIDE_SERVICE_MODE:
      return "WHITELISTOPERATION_INFORMATION_SERVICE_KEY_ATTEMPTING_TO_ADD_SERVICE_TECH_OUTSIDE_SERVICE_MODE";
    case WhitelistOperationInformationE.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum ClosureStateE {
  CLOSURESTATE_CLOSED = 0,
  CLOSURESTATE_OPEN = 1,
  CLOSURESTATE_AJAR = 2,
  CLOSURESTATE_UNKNOWN = 3,
  CLOSURESTATE_FAILED_UNLATCH = 4,
  CLOSURESTATE_OPENING = 5,
  CLOSURESTATE_CLOSING = 6,
  UNRECOGNIZED = -1,
}

export function closureStateEFromJSON(object: any): ClosureStateE {
  switch (object) {
    case 0:
    case "CLOSURESTATE_CLOSED":
      return ClosureStateE.CLOSURESTATE_CLOSED;
    case 1:
    case "CLOSURESTATE_OPEN":
      return ClosureStateE.CLOSURESTATE_OPEN;
    case 2:
    case "CLOSURESTATE_AJAR":
      return ClosureStateE.CLOSURESTATE_AJAR;
    case 3:
    case "CLOSURESTATE_UNKNOWN":
      return ClosureStateE.CLOSURESTATE_UNKNOWN;
    case 4:
    case "CLOSURESTATE_FAILED_UNLATCH":
      return ClosureStateE.CLOSURESTATE_FAILED_UNLATCH;
    case 5:
    case "CLOSURESTATE_OPENING":
      return ClosureStateE.CLOSURESTATE_OPENING;
    case 6:
    case "CLOSURESTATE_CLOSING":
      return ClosureStateE.CLOSURESTATE_CLOSING;
    case -1:
    case "UNRECOGNIZED":
    default:
      return ClosureStateE.UNRECOGNIZED;
  }
}

export function closureStateEToJSON(object: ClosureStateE): string {
  switch (object) {
    case ClosureStateE.CLOSURESTATE_CLOSED:
      return "CLOSURESTATE_CLOSED";
    case ClosureStateE.CLOSURESTATE_OPEN:
      return "CLOSURESTATE_OPEN";
    case ClosureStateE.CLOSURESTATE_AJAR:
      return "CLOSURESTATE_AJAR";
    case ClosureStateE.CLOSURESTATE_UNKNOWN:
      return "CLOSURESTATE_UNKNOWN";
    case ClosureStateE.CLOSURESTATE_FAILED_UNLATCH:
      return "CLOSURESTATE_FAILED_UNLATCH";
    case ClosureStateE.CLOSURESTATE_OPENING:
      return "CLOSURESTATE_OPENING";
    case ClosureStateE.CLOSURESTATE_CLOSING:
      return "CLOSURESTATE_CLOSING";
    case ClosureStateE.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum VehicleLockStateE {
  VEHICLELOCKSTATE_UNLOCKED = 0,
  VEHICLELOCKSTATE_LOCKED = 1,
  VEHICLELOCKSTATE_INTERNAL_LOCKED = 2,
  VEHICLELOCKSTATE_SELECTIVE_UNLOCKED = 3,
  UNRECOGNIZED = -1,
}

export function vehicleLockStateEFromJSON(object: any): VehicleLockStateE {
  switch (object) {
    case 0:
    case "VEHICLELOCKSTATE_UNLOCKED":
      return VehicleLockStateE.VEHICLELOCKSTATE_UNLOCKED;
    case 1:
    case "VEHICLELOCKSTATE_LOCKED":
      return VehicleLockStateE.VEHICLELOCKSTATE_LOCKED;
    case 2:
    case "VEHICLELOCKSTATE_INTERNAL_LOCKED":
      return VehicleLockStateE.VEHICLELOCKSTATE_INTERNAL_LOCKED;
    case 3:
    case "VEHICLELOCKSTATE_SELECTIVE_UNLOCKED":
      return VehicleLockStateE.VEHICLELOCKSTATE_SELECTIVE_UNLOCKED;
    case -1:
    case "UNRECOGNIZED":
    default:
      return VehicleLockStateE.UNRECOGNIZED;
  }
}

export function vehicleLockStateEToJSON(object: VehicleLockStateE): string {
  switch (object) {
    case VehicleLockStateE.VEHICLELOCKSTATE_UNLOCKED:
      return "VEHICLELOCKSTATE_UNLOCKED";
    case VehicleLockStateE.VEHICLELOCKSTATE_LOCKED:
      return "VEHICLELOCKSTATE_LOCKED";
    case VehicleLockStateE.VEHICLELOCKSTATE_INTERNAL_LOCKED:
      return "VEHICLELOCKSTATE_INTERNAL_LOCKED";
    case VehicleLockStateE.VEHICLELOCKSTATE_SELECTIVE_UNLOCKED:
      return "VEHICLELOCKSTATE_SELECTIVE_UNLOCKED";
    case VehicleLockStateE.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum VehicleSleepStatusE {
  VEHICLE_SLEEP_STATUS_UNKNOWN = 0,
  VEHICLE_SLEEP_STATUS_AWAKE = 1,
  VEHICLE_SLEEP_STATUS_ASLEEP = 2,
  UNRECOGNIZED = -1,
}

export function vehicleSleepStatusEFromJSON(object: any): VehicleSleepStatusE {
  switch (object) {
    case 0:
    case "VEHICLE_SLEEP_STATUS_UNKNOWN":
      return VehicleSleepStatusE.VEHICLE_SLEEP_STATUS_UNKNOWN;
    case 1:
    case "VEHICLE_SLEEP_STATUS_AWAKE":
      return VehicleSleepStatusE.VEHICLE_SLEEP_STATUS_AWAKE;
    case 2:
    case "VEHICLE_SLEEP_STATUS_ASLEEP":
      return VehicleSleepStatusE.VEHICLE_SLEEP_STATUS_ASLEEP;
    case -1:
    case "UNRECOGNIZED":
    default:
      return VehicleSleepStatusE.UNRECOGNIZED;
  }
}

export function vehicleSleepStatusEToJSON(object: VehicleSleepStatusE): string {
  switch (object) {
    case VehicleSleepStatusE.VEHICLE_SLEEP_STATUS_UNKNOWN:
      return "VEHICLE_SLEEP_STATUS_UNKNOWN";
    case VehicleSleepStatusE.VEHICLE_SLEEP_STATUS_AWAKE:
      return "VEHICLE_SLEEP_STATUS_AWAKE";
    case VehicleSleepStatusE.VEHICLE_SLEEP_STATUS_ASLEEP:
      return "VEHICLE_SLEEP_STATUS_ASLEEP";
    case VehicleSleepStatusE.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum UserPresenceE {
  VEHICLE_USER_PRESENCE_UNKNOWN = 0,
  VEHICLE_USER_PRESENCE_NOT_PRESENT = 1,
  VEHICLE_USER_PRESENCE_PRESENT = 2,
  UNRECOGNIZED = -1,
}

export function userPresenceEFromJSON(object: any): UserPresenceE {
  switch (object) {
    case 0:
    case "VEHICLE_USER_PRESENCE_UNKNOWN":
      return UserPresenceE.VEHICLE_USER_PRESENCE_UNKNOWN;
    case 1:
    case "VEHICLE_USER_PRESENCE_NOT_PRESENT":
      return UserPresenceE.VEHICLE_USER_PRESENCE_NOT_PRESENT;
    case 2:
    case "VEHICLE_USER_PRESENCE_PRESENT":
      return UserPresenceE.VEHICLE_USER_PRESENCE_PRESENT;
    case -1:
    case "UNRECOGNIZED":
    default:
      return UserPresenceE.UNRECOGNIZED;
  }
}

export function userPresenceEToJSON(object: UserPresenceE): string {
  switch (object) {
    case UserPresenceE.VEHICLE_USER_PRESENCE_UNKNOWN:
      return "VEHICLE_USER_PRESENCE_UNKNOWN";
    case UserPresenceE.VEHICLE_USER_PRESENCE_NOT_PRESENT:
      return "VEHICLE_USER_PRESENCE_NOT_PRESENT";
    case UserPresenceE.VEHICLE_USER_PRESENCE_PRESENT:
      return "VEHICLE_USER_PRESENCE_PRESENT";
    case UserPresenceE.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export interface SignedMessage {
  protobufMessageAsBytes: Uint8Array;
  signatureType: SignatureType;
}

export interface ToVCSECMessage {
  signedMessage: SignedMessage | undefined;
}

export interface KeyIdentifier {
  publicKeySHA1: Uint8Array;
}

export interface KeyMetadata {
  keyFormFactor: KeyFormFactor;
}

export interface PublicKey {
  PublicKeyRaw: Uint8Array;
}

export interface WhitelistInfo {
  numberOfEntries: number;
  whitelistEntries: KeyIdentifier[];
  slotMask: number;
}

export interface WhitelistEntryInfo {
  keyId: KeyIdentifier | undefined;
  publicKey: PublicKey | undefined;
  metadataForKey: KeyMetadata | undefined;
  slot: number;
  keyRole: Role;
}

export interface InformationRequest {
  informationRequestType: InformationRequestType;
  keyId?: KeyIdentifier | undefined;
  publicKey?: Uint8Array | undefined;
  slot?: number | undefined;
}

export interface ClosureMoveRequest {
  frontDriverDoor: ClosureMoveTypeE;
  frontPassengerDoor: ClosureMoveTypeE;
  rearDriverDoor: ClosureMoveTypeE;
  rearPassengerDoor: ClosureMoveTypeE;
  rearTrunk: ClosureMoveTypeE;
  frontTrunk: ClosureMoveTypeE;
  chargePort: ClosureMoveTypeE;
  tonneau: ClosureMoveTypeE;
}

export interface PermissionChange {
  key: PublicKey | undefined;
  secondsToBeActive: number;
  keyRole: Role;
}

export interface ReplaceKey {
  publicKeyToReplace?: PublicKey | undefined;
  slotToReplace?: number | undefined;
  keyToAdd: PublicKey | undefined;
  keyRole: Role;
  impermanent: boolean;
}

export interface WhitelistOperation {
  addPublicKeyToWhitelist?: PublicKey | undefined;
  removePublicKeyFromWhitelist?: PublicKey | undefined;
  addPermissionsToPublicKey?: PermissionChange | undefined;
  removePermissionsFromPublicKey?: PermissionChange | undefined;
  addKeyToWhitelistAndAddPermissions?: PermissionChange | undefined;
  updateKeyAndPermissions?: PermissionChange | undefined;
  addImpermanentKey?: PermissionChange | undefined;
  addImpermanentKeyAndRemoveExisting?: PermissionChange | undefined;
  removeAllImpermanentKeys?: boolean | undefined;
  replaceKey?: ReplaceKey | undefined;
  metadataForKey: KeyMetadata | undefined;
}

export interface WhitelistOperationStatus {
  whitelistOperationInformation: WhitelistOperationInformationE;
  signerOfOperation: KeyIdentifier | undefined;
  operationStatus: OperationStatusE;
}

export interface SignedMessageStatus {
  counter: number;
  signedMessageInformation: SignedMessageInformationE;
}

export interface CommandStatus {
  operationStatus: OperationStatusE;
  signedMessageStatus?: SignedMessageStatus | undefined;
  whitelistOperationStatus?: WhitelistOperationStatus | undefined;
}

export interface UnsignedMessage {
  InformationRequest?: InformationRequest | undefined;
  RKEAction?: RKEActionE | undefined;
  closureMoveRequest?: ClosureMoveRequest | undefined;
  WhitelistOperation?: WhitelistOperation | undefined;
}

export interface ClosureStatuses {
  frontDriverDoor: ClosureStateE;
  frontPassengerDoor: ClosureStateE;
  rearDriverDoor: ClosureStateE;
  rearPassengerDoor: ClosureStateE;
  rearTrunk: ClosureStateE;
  frontTrunk: ClosureStateE;
  chargePort: ClosureStateE;
  tonneau: ClosureStateE;
}

export interface DetailedClosureStatus {
  tonneauPercentOpen: number;
}

export interface VehicleStatus {
  closureStatuses: ClosureStatuses | undefined;
  vehicleLockState: VehicleLockStateE;
  vehicleSleepStatus: VehicleSleepStatusE;
  userPresence: UserPresenceE;
  detailedClosureStatus: DetailedClosureStatus | undefined;
}

export interface FromVCSECMessage {
  vehicleStatus?: VehicleStatus | undefined;
  commandStatus?: CommandStatus | undefined;
  whitelistInfo?: WhitelistInfo | undefined;
  whitelistEntryInfo?: WhitelistEntryInfo | undefined;
  nominalError?: NominalError | undefined;
}

function createBaseSignedMessage(): SignedMessage {
  return { protobufMessageAsBytes: new Uint8Array(0), signatureType: 0 };
}

export const SignedMessage: MessageFns<SignedMessage> = {
  encode(message: SignedMessage, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.protobufMessageAsBytes.length !== 0) {
      writer.uint32(18).bytes(message.protobufMessageAsBytes);
    }
    if (message.signatureType !== 0) {
      writer.uint32(24).int32(message.signatureType);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SignedMessage {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSignedMessage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.protobufMessageAsBytes = reader.bytes();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.signatureType = reader.int32() as any;
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SignedMessage {
    return {
      protobufMessageAsBytes: isSet(object.protobufMessageAsBytes)
        ? bytesFromBase64(object.protobufMessageAsBytes)
        : new Uint8Array(0),
      signatureType: isSet(object.signatureType) ? signatureTypeFromJSON(object.signatureType) : 0,
    };
  },

  toJSON(message: SignedMessage): unknown {
    const obj: any = {};
    if (message.protobufMessageAsBytes.length !== 0) {
      obj.protobufMessageAsBytes = base64FromBytes(message.protobufMessageAsBytes);
    }
    if (message.signatureType !== 0) {
      obj.signatureType = signatureTypeToJSON(message.signatureType);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SignedMessage>, I>>(base?: I): SignedMessage {
    return SignedMessage.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SignedMessage>, I>>(object: I): SignedMessage {
    const message = createBaseSignedMessage();
    message.protobufMessageAsBytes = object.protobufMessageAsBytes ?? new Uint8Array(0);
    message.signatureType = object.signatureType ?? 0;
    return message;
  },
};

function createBaseToVCSECMessage(): ToVCSECMessage {
  return { signedMessage: undefined };
}

export const ToVCSECMessage: MessageFns<ToVCSECMessage> = {
  encode(message: ToVCSECMessage, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.signedMessage !== undefined) {
      SignedMessage.encode(message.signedMessage, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ToVCSECMessage {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseToVCSECMessage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.signedMessage = SignedMessage.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ToVCSECMessage {
    return { signedMessage: isSet(object.signedMessage) ? SignedMessage.fromJSON(object.signedMessage) : undefined };
  },

  toJSON(message: ToVCSECMessage): unknown {
    const obj: any = {};
    if (message.signedMessage !== undefined) {
      obj.signedMessage = SignedMessage.toJSON(message.signedMessage);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ToVCSECMessage>, I>>(base?: I): ToVCSECMessage {
    return ToVCSECMessage.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ToVCSECMessage>, I>>(object: I): ToVCSECMessage {
    const message = createBaseToVCSECMessage();
    message.signedMessage = (object.signedMessage !== undefined && object.signedMessage !== null)
      ? SignedMessage.fromPartial(object.signedMessage)
      : undefined;
    return message;
  },
};

function createBaseKeyIdentifier(): KeyIdentifier {
  return { publicKeySHA1: new Uint8Array(0) };
}

export const KeyIdentifier: MessageFns<KeyIdentifier> = {
  encode(message: KeyIdentifier, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.publicKeySHA1.length !== 0) {
      writer.uint32(10).bytes(message.publicKeySHA1);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): KeyIdentifier {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseKeyIdentifier();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.publicKeySHA1 = reader.bytes();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): KeyIdentifier {
    return { publicKeySHA1: isSet(object.publicKeySHA1) ? bytesFromBase64(object.publicKeySHA1) : new Uint8Array(0) };
  },

  toJSON(message: KeyIdentifier): unknown {
    const obj: any = {};
    if (message.publicKeySHA1.length !== 0) {
      obj.publicKeySHA1 = base64FromBytes(message.publicKeySHA1);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<KeyIdentifier>, I>>(base?: I): KeyIdentifier {
    return KeyIdentifier.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<KeyIdentifier>, I>>(object: I): KeyIdentifier {
    const message = createBaseKeyIdentifier();
    message.publicKeySHA1 = object.publicKeySHA1 ?? new Uint8Array(0);
    return message;
  },
};

function createBaseKeyMetadata(): KeyMetadata {
  return { keyFormFactor: 0 };
}

export const KeyMetadata: MessageFns<KeyMetadata> = {
  encode(message: KeyMetadata, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.keyFormFactor !== 0) {
      writer.uint32(8).int32(message.keyFormFactor);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): KeyMetadata {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseKeyMetadata();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.keyFormFactor = reader.int32() as any;
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): KeyMetadata {
    return { keyFormFactor: isSet(object.keyFormFactor) ? keyFormFactorFromJSON(object.keyFormFactor) : 0 };
  },

  toJSON(message: KeyMetadata): unknown {
    const obj: any = {};
    if (message.keyFormFactor !== 0) {
      obj.keyFormFactor = keyFormFactorToJSON(message.keyFormFactor);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<KeyMetadata>, I>>(base?: I): KeyMetadata {
    return KeyMetadata.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<KeyMetadata>, I>>(object: I): KeyMetadata {
    const message = createBaseKeyMetadata();
    message.keyFormFactor = object.keyFormFactor ?? 0;
    return message;
  },
};

function createBasePublicKey(): PublicKey {
  return { PublicKeyRaw: new Uint8Array(0) };
}

export const PublicKey: MessageFns<PublicKey> = {
  encode(message: PublicKey, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.PublicKeyRaw.length !== 0) {
      writer.uint32(10).bytes(message.PublicKeyRaw);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PublicKey {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePublicKey();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.PublicKeyRaw = reader.bytes();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PublicKey {
    return { PublicKeyRaw: isSet(object.PublicKeyRaw) ? bytesFromBase64(object.PublicKeyRaw) : new Uint8Array(0) };
  },

  toJSON(message: PublicKey): unknown {
    const obj: any = {};
    if (message.PublicKeyRaw.length !== 0) {
      obj.PublicKeyRaw = base64FromBytes(message.PublicKeyRaw);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PublicKey>, I>>(base?: I): PublicKey {
    return PublicKey.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PublicKey>, I>>(object: I): PublicKey {
    const message = createBasePublicKey();
    message.PublicKeyRaw = object.PublicKeyRaw ?? new Uint8Array(0);
    return message;
  },
};

function createBaseWhitelistInfo(): WhitelistInfo {
  return { numberOfEntries: 0, whitelistEntries: [], slotMask: 0 };
}

export const WhitelistInfo: MessageFns<WhitelistInfo> = {
  encode(message: WhitelistInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.numberOfEntries !== 0) {
      writer.uint32(8).uint32(message.numberOfEntries);
    }
    for (const v of message.whitelistEntries) {
      KeyIdentifier.encode(v!, writer.uint32(18).fork()).join();
    }
    if (message.slotMask !== 0) {
      writer.uint32(24).uint32(message.slotMask);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WhitelistInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWhitelistInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.numberOfEntries = reader.uint32();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.whitelistEntries.push(KeyIdentifier.decode(reader, reader.uint32()));
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.slotMask = reader.uint32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): WhitelistInfo {
    return {
      numberOfEntries: isSet(object.numberOfEntries) ? globalThis.Number(object.numberOfEntries) : 0,
      whitelistEntries: globalThis.Array.isArray(object?.whitelistEntries)
        ? object.whitelistEntries.map((e: any) => KeyIdentifier.fromJSON(e))
        : [],
      slotMask: isSet(object.slotMask) ? globalThis.Number(object.slotMask) : 0,
    };
  },

  toJSON(message: WhitelistInfo): unknown {
    const obj: any = {};
    if (message.numberOfEntries !== 0) {
      obj.numberOfEntries = Math.round(message.numberOfEntries);
    }
    if (message.whitelistEntries?.length) {
      obj.whitelistEntries = message.whitelistEntries.map((e) => KeyIdentifier.toJSON(e));
    }
    if (message.slotMask !== 0) {
      obj.slotMask = Math.round(message.slotMask);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<WhitelistInfo>, I>>(base?: I): WhitelistInfo {
    return WhitelistInfo.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<WhitelistInfo>, I>>(object: I): WhitelistInfo {
    const message = createBaseWhitelistInfo();
    message.numberOfEntries = object.numberOfEntries ?? 0;
    message.whitelistEntries = object.whitelistEntries?.map((e) => KeyIdentifier.fromPartial(e)) || [];
    message.slotMask = object.slotMask ?? 0;
    return message;
  },
};

function createBaseWhitelistEntryInfo(): WhitelistEntryInfo {
  return { keyId: undefined, publicKey: undefined, metadataForKey: undefined, slot: 0, keyRole: 0 };
}

export const WhitelistEntryInfo: MessageFns<WhitelistEntryInfo> = {
  encode(message: WhitelistEntryInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.keyId !== undefined) {
      KeyIdentifier.encode(message.keyId, writer.uint32(10).fork()).join();
    }
    if (message.publicKey !== undefined) {
      PublicKey.encode(message.publicKey, writer.uint32(18).fork()).join();
    }
    if (message.metadataForKey !== undefined) {
      KeyMetadata.encode(message.metadataForKey, writer.uint32(34).fork()).join();
    }
    if (message.slot !== 0) {
      writer.uint32(48).uint32(message.slot);
    }
    if (message.keyRole !== 0) {
      writer.uint32(56).int32(message.keyRole);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WhitelistEntryInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWhitelistEntryInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.keyId = KeyIdentifier.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.publicKey = PublicKey.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.metadataForKey = KeyMetadata.decode(reader, reader.uint32());
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.slot = reader.uint32();
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.keyRole = reader.int32() as any;
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): WhitelistEntryInfo {
    return {
      keyId: isSet(object.keyId) ? KeyIdentifier.fromJSON(object.keyId) : undefined,
      publicKey: isSet(object.publicKey) ? PublicKey.fromJSON(object.publicKey) : undefined,
      metadataForKey: isSet(object.metadataForKey) ? KeyMetadata.fromJSON(object.metadataForKey) : undefined,
      slot: isSet(object.slot) ? globalThis.Number(object.slot) : 0,
      keyRole: isSet(object.keyRole) ? roleFromJSON(object.keyRole) : 0,
    };
  },

  toJSON(message: WhitelistEntryInfo): unknown {
    const obj: any = {};
    if (message.keyId !== undefined) {
      obj.keyId = KeyIdentifier.toJSON(message.keyId);
    }
    if (message.publicKey !== undefined) {
      obj.publicKey = PublicKey.toJSON(message.publicKey);
    }
    if (message.metadataForKey !== undefined) {
      obj.metadataForKey = KeyMetadata.toJSON(message.metadataForKey);
    }
    if (message.slot !== 0) {
      obj.slot = Math.round(message.slot);
    }
    if (message.keyRole !== 0) {
      obj.keyRole = roleToJSON(message.keyRole);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<WhitelistEntryInfo>, I>>(base?: I): WhitelistEntryInfo {
    return WhitelistEntryInfo.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<WhitelistEntryInfo>, I>>(object: I): WhitelistEntryInfo {
    const message = createBaseWhitelistEntryInfo();
    message.keyId = (object.keyId !== undefined && object.keyId !== null)
      ? KeyIdentifier.fromPartial(object.keyId)
      : undefined;
    message.publicKey = (object.publicKey !== undefined && object.publicKey !== null)
      ? PublicKey.fromPartial(object.publicKey)
      : undefined;
    message.metadataForKey = (object.metadataForKey !== undefined && object.metadataForKey !== null)
      ? KeyMetadata.fromPartial(object.metadataForKey)
      : undefined;
    message.slot = object.slot ?? 0;
    message.keyRole = object.keyRole ?? 0;
    return message;
  },
};

function createBaseInformationRequest(): InformationRequest {
  return { informationRequestType: 0, keyId: undefined, publicKey: undefined, slot: undefined };
}

export const InformationRequest: MessageFns<InformationRequest> = {
  encode(message: InformationRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.informationRequestType !== 0) {
      writer.uint32(8).int32(message.informationRequestType);
    }
    if (message.keyId !== undefined) {
      KeyIdentifier.encode(message.keyId, writer.uint32(18).fork()).join();
    }
    if (message.publicKey !== undefined) {
      writer.uint32(26).bytes(message.publicKey);
    }
    if (message.slot !== undefined) {
      writer.uint32(32).uint32(message.slot);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): InformationRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseInformationRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.informationRequestType = reader.int32() as any;
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.keyId = KeyIdentifier.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.publicKey = reader.bytes();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.slot = reader.uint32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): InformationRequest {
    return {
      informationRequestType: isSet(object.informationRequestType)
        ? informationRequestTypeFromJSON(object.informationRequestType)
        : 0,
      keyId: isSet(object.keyId) ? KeyIdentifier.fromJSON(object.keyId) : undefined,
      publicKey: isSet(object.publicKey) ? bytesFromBase64(object.publicKey) : undefined,
      slot: isSet(object.slot) ? globalThis.Number(object.slot) : undefined,
    };
  },

  toJSON(message: InformationRequest): unknown {
    const obj: any = {};
    if (message.informationRequestType !== 0) {
      obj.informationRequestType = informationRequestTypeToJSON(message.informationRequestType);
    }
    if (message.keyId !== undefined) {
      obj.keyId = KeyIdentifier.toJSON(message.keyId);
    }
    if (message.publicKey !== undefined) {
      obj.publicKey = base64FromBytes(message.publicKey);
    }
    if (message.slot !== undefined) {
      obj.slot = Math.round(message.slot);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<InformationRequest>, I>>(base?: I): InformationRequest {
    return InformationRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<InformationRequest>, I>>(object: I): InformationRequest {
    const message = createBaseInformationRequest();
    message.informationRequestType = object.informationRequestType ?? 0;
    message.keyId = (object.keyId !== undefined && object.keyId !== null)
      ? KeyIdentifier.fromPartial(object.keyId)
      : undefined;
    message.publicKey = object.publicKey ?? undefined;
    message.slot = object.slot ?? undefined;
    return message;
  },
};

function createBaseClosureMoveRequest(): ClosureMoveRequest {
  return {
    frontDriverDoor: 0,
    frontPassengerDoor: 0,
    rearDriverDoor: 0,
    rearPassengerDoor: 0,
    rearTrunk: 0,
    frontTrunk: 0,
    chargePort: 0,
    tonneau: 0,
  };
}

export const ClosureMoveRequest: MessageFns<ClosureMoveRequest> = {
  encode(message: ClosureMoveRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.frontDriverDoor !== 0) {
      writer.uint32(8).int32(message.frontDriverDoor);
    }
    if (message.frontPassengerDoor !== 0) {
      writer.uint32(16).int32(message.frontPassengerDoor);
    }
    if (message.rearDriverDoor !== 0) {
      writer.uint32(24).int32(message.rearDriverDoor);
    }
    if (message.rearPassengerDoor !== 0) {
      writer.uint32(32).int32(message.rearPassengerDoor);
    }
    if (message.rearTrunk !== 0) {
      writer.uint32(40).int32(message.rearTrunk);
    }
    if (message.frontTrunk !== 0) {
      writer.uint32(48).int32(message.frontTrunk);
    }
    if (message.chargePort !== 0) {
      writer.uint32(56).int32(message.chargePort);
    }
    if (message.tonneau !== 0) {
      writer.uint32(64).int32(message.tonneau);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ClosureMoveRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseClosureMoveRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.frontDriverDoor = reader.int32() as any;
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.frontPassengerDoor = reader.int32() as any;
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.rearDriverDoor = reader.int32() as any;
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.rearPassengerDoor = reader.int32() as any;
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.rearTrunk = reader.int32() as any;
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.frontTrunk = reader.int32() as any;
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.chargePort = reader.int32() as any;
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.tonneau = reader.int32() as any;
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ClosureMoveRequest {
    return {
      frontDriverDoor: isSet(object.frontDriverDoor) ? closureMoveTypeEFromJSON(object.frontDriverDoor) : 0,
      frontPassengerDoor: isSet(object.frontPassengerDoor) ? closureMoveTypeEFromJSON(object.frontPassengerDoor) : 0,
      rearDriverDoor: isSet(object.rearDriverDoor) ? closureMoveTypeEFromJSON(object.rearDriverDoor) : 0,
      rearPassengerDoor: isSet(object.rearPassengerDoor) ? closureMoveTypeEFromJSON(object.rearPassengerDoor) : 0,
      rearTrunk: isSet(object.rearTrunk) ? closureMoveTypeEFromJSON(object.rearTrunk) : 0,
      frontTrunk: isSet(object.frontTrunk) ? closureMoveTypeEFromJSON(object.frontTrunk) : 0,
      chargePort: isSet(object.chargePort) ? closureMoveTypeEFromJSON(object.chargePort) : 0,
      tonneau: isSet(object.tonneau) ? closureMoveTypeEFromJSON(object.tonneau) : 0,
    };
  },

  toJSON(message: ClosureMoveRequest): unknown {
    const obj: any = {};
    if (message.frontDriverDoor !== 0) {
      obj.frontDriverDoor = closureMoveTypeEToJSON(message.frontDriverDoor);
    }
    if (message.frontPassengerDoor !== 0) {
      obj.frontPassengerDoor = closureMoveTypeEToJSON(message.frontPassengerDoor);
    }
    if (message.rearDriverDoor !== 0) {
      obj.rearDriverDoor = closureMoveTypeEToJSON(message.rearDriverDoor);
    }
    if (message.rearPassengerDoor !== 0) {
      obj.rearPassengerDoor = closureMoveTypeEToJSON(message.rearPassengerDoor);
    }
    if (message.rearTrunk !== 0) {
      obj.rearTrunk = closureMoveTypeEToJSON(message.rearTrunk);
    }
    if (message.frontTrunk !== 0) {
      obj.frontTrunk = closureMoveTypeEToJSON(message.frontTrunk);
    }
    if (message.chargePort !== 0) {
      obj.chargePort = closureMoveTypeEToJSON(message.chargePort);
    }
    if (message.tonneau !== 0) {
      obj.tonneau = closureMoveTypeEToJSON(message.tonneau);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ClosureMoveRequest>, I>>(base?: I): ClosureMoveRequest {
    return ClosureMoveRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ClosureMoveRequest>, I>>(object: I): ClosureMoveRequest {
    const message = createBaseClosureMoveRequest();
    message.frontDriverDoor = object.frontDriverDoor ?? 0;
    message.frontPassengerDoor = object.frontPassengerDoor ?? 0;
    message.rearDriverDoor = object.rearDriverDoor ?? 0;
    message.rearPassengerDoor = object.rearPassengerDoor ?? 0;
    message.rearTrunk = object.rearTrunk ?? 0;
    message.frontTrunk = object.frontTrunk ?? 0;
    message.chargePort = object.chargePort ?? 0;
    message.tonneau = object.tonneau ?? 0;
    return message;
  },
};

function createBasePermissionChange(): PermissionChange {
  return { key: undefined, secondsToBeActive: 0, keyRole: 0 };
}

export const PermissionChange: MessageFns<PermissionChange> = {
  encode(message: PermissionChange, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== undefined) {
      PublicKey.encode(message.key, writer.uint32(10).fork()).join();
    }
    if (message.secondsToBeActive !== 0) {
      writer.uint32(24).uint32(message.secondsToBeActive);
    }
    if (message.keyRole !== 0) {
      writer.uint32(32).int32(message.keyRole);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PermissionChange {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePermissionChange();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = PublicKey.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.secondsToBeActive = reader.uint32();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.keyRole = reader.int32() as any;
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PermissionChange {
    return {
      key: isSet(object.key) ? PublicKey.fromJSON(object.key) : undefined,
      secondsToBeActive: isSet(object.secondsToBeActive) ? globalThis.Number(object.secondsToBeActive) : 0,
      keyRole: isSet(object.keyRole) ? roleFromJSON(object.keyRole) : 0,
    };
  },

  toJSON(message: PermissionChange): unknown {
    const obj: any = {};
    if (message.key !== undefined) {
      obj.key = PublicKey.toJSON(message.key);
    }
    if (message.secondsToBeActive !== 0) {
      obj.secondsToBeActive = Math.round(message.secondsToBeActive);
    }
    if (message.keyRole !== 0) {
      obj.keyRole = roleToJSON(message.keyRole);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PermissionChange>, I>>(base?: I): PermissionChange {
    return PermissionChange.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PermissionChange>, I>>(object: I): PermissionChange {
    const message = createBasePermissionChange();
    message.key = (object.key !== undefined && object.key !== null) ? PublicKey.fromPartial(object.key) : undefined;
    message.secondsToBeActive = object.secondsToBeActive ?? 0;
    message.keyRole = object.keyRole ?? 0;
    return message;
  },
};

function createBaseReplaceKey(): ReplaceKey {
  return {
    publicKeyToReplace: undefined,
    slotToReplace: undefined,
    keyToAdd: undefined,
    keyRole: 0,
    impermanent: false,
  };
}

export const ReplaceKey: MessageFns<ReplaceKey> = {
  encode(message: ReplaceKey, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.publicKeyToReplace !== undefined) {
      PublicKey.encode(message.publicKeyToReplace, writer.uint32(10).fork()).join();
    }
    if (message.slotToReplace !== undefined) {
      writer.uint32(16).uint32(message.slotToReplace);
    }
    if (message.keyToAdd !== undefined) {
      PublicKey.encode(message.keyToAdd, writer.uint32(26).fork()).join();
    }
    if (message.keyRole !== 0) {
      writer.uint32(32).int32(message.keyRole);
    }
    if (message.impermanent !== false) {
      writer.uint32(40).bool(message.impermanent);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ReplaceKey {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseReplaceKey();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.publicKeyToReplace = PublicKey.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.slotToReplace = reader.uint32();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.keyToAdd = PublicKey.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.keyRole = reader.int32() as any;
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.impermanent = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ReplaceKey {
    return {
      publicKeyToReplace: isSet(object.publicKeyToReplace) ? PublicKey.fromJSON(object.publicKeyToReplace) : undefined,
      slotToReplace: isSet(object.slotToReplace) ? globalThis.Number(object.slotToReplace) : undefined,
      keyToAdd: isSet(object.keyToAdd) ? PublicKey.fromJSON(object.keyToAdd) : undefined,
      keyRole: isSet(object.keyRole) ? roleFromJSON(object.keyRole) : 0,
      impermanent: isSet(object.impermanent) ? globalThis.Boolean(object.impermanent) : false,
    };
  },

  toJSON(message: ReplaceKey): unknown {
    const obj: any = {};
    if (message.publicKeyToReplace !== undefined) {
      obj.publicKeyToReplace = PublicKey.toJSON(message.publicKeyToReplace);
    }
    if (message.slotToReplace !== undefined) {
      obj.slotToReplace = Math.round(message.slotToReplace);
    }
    if (message.keyToAdd !== undefined) {
      obj.keyToAdd = PublicKey.toJSON(message.keyToAdd);
    }
    if (message.keyRole !== 0) {
      obj.keyRole = roleToJSON(message.keyRole);
    }
    if (message.impermanent !== false) {
      obj.impermanent = message.impermanent;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ReplaceKey>, I>>(base?: I): ReplaceKey {
    return ReplaceKey.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ReplaceKey>, I>>(object: I): ReplaceKey {
    const message = createBaseReplaceKey();
    message.publicKeyToReplace = (object.publicKeyToReplace !== undefined && object.publicKeyToReplace !== null)
      ? PublicKey.fromPartial(object.publicKeyToReplace)
      : undefined;
    message.slotToReplace = object.slotToReplace ?? undefined;
    message.keyToAdd = (object.keyToAdd !== undefined && object.keyToAdd !== null)
      ? PublicKey.fromPartial(object.keyToAdd)
      : undefined;
    message.keyRole = object.keyRole ?? 0;
    message.impermanent = object.impermanent ?? false;
    return message;
  },
};

function createBaseWhitelistOperation(): WhitelistOperation {
  return {
    addPublicKeyToWhitelist: undefined,
    removePublicKeyFromWhitelist: undefined,
    addPermissionsToPublicKey: undefined,
    removePermissionsFromPublicKey: undefined,
    addKeyToWhitelistAndAddPermissions: undefined,
    updateKeyAndPermissions: undefined,
    addImpermanentKey: undefined,
    addImpermanentKeyAndRemoveExisting: undefined,
    removeAllImpermanentKeys: undefined,
    replaceKey: undefined,
    metadataForKey: undefined,
  };
}

export const WhitelistOperation: MessageFns<WhitelistOperation> = {
  encode(message: WhitelistOperation, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.addPublicKeyToWhitelist !== undefined) {
      PublicKey.encode(message.addPublicKeyToWhitelist, writer.uint32(10).fork()).join();
    }
    if (message.removePublicKeyFromWhitelist !== undefined) {
      PublicKey.encode(message.removePublicKeyFromWhitelist, writer.uint32(18).fork()).join();
    }
    if (message.addPermissionsToPublicKey !== undefined) {
      PermissionChange.encode(message.addPermissionsToPublicKey, writer.uint32(26).fork()).join();
    }
    if (message.removePermissionsFromPublicKey !== undefined) {
      PermissionChange.encode(message.removePermissionsFromPublicKey, writer.uint32(34).fork()).join();
    }
    if (message.addKeyToWhitelistAndAddPermissions !== undefined) {
      PermissionChange.encode(message.addKeyToWhitelistAndAddPermissions, writer.uint32(42).fork()).join();
    }
    if (message.updateKeyAndPermissions !== undefined) {
      PermissionChange.encode(message.updateKeyAndPermissions, writer.uint32(58).fork()).join();
    }
    if (message.addImpermanentKey !== undefined) {
      PermissionChange.encode(message.addImpermanentKey, writer.uint32(66).fork()).join();
    }
    if (message.addImpermanentKeyAndRemoveExisting !== undefined) {
      PermissionChange.encode(message.addImpermanentKeyAndRemoveExisting, writer.uint32(74).fork()).join();
    }
    if (message.removeAllImpermanentKeys !== undefined) {
      writer.uint32(128).bool(message.removeAllImpermanentKeys);
    }
    if (message.replaceKey !== undefined) {
      ReplaceKey.encode(message.replaceKey, writer.uint32(138).fork()).join();
    }
    if (message.metadataForKey !== undefined) {
      KeyMetadata.encode(message.metadataForKey, writer.uint32(50).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WhitelistOperation {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWhitelistOperation();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.addPublicKeyToWhitelist = PublicKey.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.removePublicKeyFromWhitelist = PublicKey.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.addPermissionsToPublicKey = PermissionChange.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.removePermissionsFromPublicKey = PermissionChange.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.addKeyToWhitelistAndAddPermissions = PermissionChange.decode(reader, reader.uint32());
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.updateKeyAndPermissions = PermissionChange.decode(reader, reader.uint32());
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.addImpermanentKey = PermissionChange.decode(reader, reader.uint32());
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.addImpermanentKeyAndRemoveExisting = PermissionChange.decode(reader, reader.uint32());
          continue;
        }
        case 16: {
          if (tag !== 128) {
            break;
          }

          message.removeAllImpermanentKeys = reader.bool();
          continue;
        }
        case 17: {
          if (tag !== 138) {
            break;
          }

          message.replaceKey = ReplaceKey.decode(reader, reader.uint32());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.metadataForKey = KeyMetadata.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): WhitelistOperation {
    return {
      addPublicKeyToWhitelist: isSet(object.addPublicKeyToWhitelist)
        ? PublicKey.fromJSON(object.addPublicKeyToWhitelist)
        : undefined,
      removePublicKeyFromWhitelist: isSet(object.removePublicKeyFromWhitelist)
        ? PublicKey.fromJSON(object.removePublicKeyFromWhitelist)
        : undefined,
      addPermissionsToPublicKey: isSet(object.addPermissionsToPublicKey)
        ? PermissionChange.fromJSON(object.addPermissionsToPublicKey)
        : undefined,
      removePermissionsFromPublicKey: isSet(object.removePermissionsFromPublicKey)
        ? PermissionChange.fromJSON(object.removePermissionsFromPublicKey)
        : undefined,
      addKeyToWhitelistAndAddPermissions: isSet(object.addKeyToWhitelistAndAddPermissions)
        ? PermissionChange.fromJSON(object.addKeyToWhitelistAndAddPermissions)
        : undefined,
      updateKeyAndPermissions: isSet(object.updateKeyAndPermissions)
        ? PermissionChange.fromJSON(object.updateKeyAndPermissions)
        : undefined,
      addImpermanentKey: isSet(object.addImpermanentKey)
        ? PermissionChange.fromJSON(object.addImpermanentKey)
        : undefined,
      addImpermanentKeyAndRemoveExisting: isSet(object.addImpermanentKeyAndRemoveExisting)
        ? PermissionChange.fromJSON(object.addImpermanentKeyAndRemoveExisting)
        : undefined,
      removeAllImpermanentKeys: isSet(object.removeAllImpermanentKeys)
        ? globalThis.Boolean(object.removeAllImpermanentKeys)
        : undefined,
      replaceKey: isSet(object.replaceKey) ? ReplaceKey.fromJSON(object.replaceKey) : undefined,
      metadataForKey: isSet(object.metadataForKey) ? KeyMetadata.fromJSON(object.metadataForKey) : undefined,
    };
  },

  toJSON(message: WhitelistOperation): unknown {
    const obj: any = {};
    if (message.addPublicKeyToWhitelist !== undefined) {
      obj.addPublicKeyToWhitelist = PublicKey.toJSON(message.addPublicKeyToWhitelist);
    }
    if (message.removePublicKeyFromWhitelist !== undefined) {
      obj.removePublicKeyFromWhitelist = PublicKey.toJSON(message.removePublicKeyFromWhitelist);
    }
    if (message.addPermissionsToPublicKey !== undefined) {
      obj.addPermissionsToPublicKey = PermissionChange.toJSON(message.addPermissionsToPublicKey);
    }
    if (message.removePermissionsFromPublicKey !== undefined) {
      obj.removePermissionsFromPublicKey = PermissionChange.toJSON(message.removePermissionsFromPublicKey);
    }
    if (message.addKeyToWhitelistAndAddPermissions !== undefined) {
      obj.addKeyToWhitelistAndAddPermissions = PermissionChange.toJSON(message.addKeyToWhitelistAndAddPermissions);
    }
    if (message.updateKeyAndPermissions !== undefined) {
      obj.updateKeyAndPermissions = PermissionChange.toJSON(message.updateKeyAndPermissions);
    }
    if (message.addImpermanentKey !== undefined) {
      obj.addImpermanentKey = PermissionChange.toJSON(message.addImpermanentKey);
    }
    if (message.addImpermanentKeyAndRemoveExisting !== undefined) {
      obj.addImpermanentKeyAndRemoveExisting = PermissionChange.toJSON(message.addImpermanentKeyAndRemoveExisting);
    }
    if (message.removeAllImpermanentKeys !== undefined) {
      obj.removeAllImpermanentKeys = message.removeAllImpermanentKeys;
    }
    if (message.replaceKey !== undefined) {
      obj.replaceKey = ReplaceKey.toJSON(message.replaceKey);
    }
    if (message.metadataForKey !== undefined) {
      obj.metadataForKey = KeyMetadata.toJSON(message.metadataForKey);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<WhitelistOperation>, I>>(base?: I): WhitelistOperation {
    return WhitelistOperation.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<WhitelistOperation>, I>>(object: I): WhitelistOperation {
    const message = createBaseWhitelistOperation();
    message.addPublicKeyToWhitelist =
      (object.addPublicKeyToWhitelist !== undefined && object.addPublicKeyToWhitelist !== null)
        ? PublicKey.fromPartial(object.addPublicKeyToWhitelist)
        : undefined;
    message.removePublicKeyFromWhitelist =
      (object.removePublicKeyFromWhitelist !== undefined && object.removePublicKeyFromWhitelist !== null)
        ? PublicKey.fromPartial(object.removePublicKeyFromWhitelist)
        : undefined;
    message.addPermissionsToPublicKey =
      (object.addPermissionsToPublicKey !== undefined && object.addPermissionsToPublicKey !== null)
        ? PermissionChange.fromPartial(object.addPermissionsToPublicKey)
        : undefined;
    message.removePermissionsFromPublicKey =
      (object.removePermissionsFromPublicKey !== undefined && object.removePermissionsFromPublicKey !== null)
        ? PermissionChange.fromPartial(object.removePermissionsFromPublicKey)
        : undefined;
    message.addKeyToWhitelistAndAddPermissions =
      (object.addKeyToWhitelistAndAddPermissions !== undefined && object.addKeyToWhitelistAndAddPermissions !== null)
        ? PermissionChange.fromPartial(object.addKeyToWhitelistAndAddPermissions)
        : undefined;
    message.updateKeyAndPermissions =
      (object.updateKeyAndPermissions !== undefined && object.updateKeyAndPermissions !== null)
        ? PermissionChange.fromPartial(object.updateKeyAndPermissions)
        : undefined;
    message.addImpermanentKey = (object.addImpermanentKey !== undefined && object.addImpermanentKey !== null)
      ? PermissionChange.fromPartial(object.addImpermanentKey)
      : undefined;
    message.addImpermanentKeyAndRemoveExisting =
      (object.addImpermanentKeyAndRemoveExisting !== undefined && object.addImpermanentKeyAndRemoveExisting !== null)
        ? PermissionChange.fromPartial(object.addImpermanentKeyAndRemoveExisting)
        : undefined;
    message.removeAllImpermanentKeys = object.removeAllImpermanentKeys ?? undefined;
    message.replaceKey = (object.replaceKey !== undefined && object.replaceKey !== null)
      ? ReplaceKey.fromPartial(object.replaceKey)
      : undefined;
    message.metadataForKey = (object.metadataForKey !== undefined && object.metadataForKey !== null)
      ? KeyMetadata.fromPartial(object.metadataForKey)
      : undefined;
    return message;
  },
};

function createBaseWhitelistOperationStatus(): WhitelistOperationStatus {
  return { whitelistOperationInformation: 0, signerOfOperation: undefined, operationStatus: 0 };
}

export const WhitelistOperationStatus: MessageFns<WhitelistOperationStatus> = {
  encode(message: WhitelistOperationStatus, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.whitelistOperationInformation !== 0) {
      writer.uint32(8).int32(message.whitelistOperationInformation);
    }
    if (message.signerOfOperation !== undefined) {
      KeyIdentifier.encode(message.signerOfOperation, writer.uint32(18).fork()).join();
    }
    if (message.operationStatus !== 0) {
      writer.uint32(24).int32(message.operationStatus);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WhitelistOperationStatus {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWhitelistOperationStatus();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.whitelistOperationInformation = reader.int32() as any;
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.signerOfOperation = KeyIdentifier.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.operationStatus = reader.int32() as any;
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): WhitelistOperationStatus {
    return {
      whitelistOperationInformation: isSet(object.whitelistOperationInformation)
        ? whitelistOperationInformationEFromJSON(object.whitelistOperationInformation)
        : 0,
      signerOfOperation: isSet(object.signerOfOperation) ? KeyIdentifier.fromJSON(object.signerOfOperation) : undefined,
      operationStatus: isSet(object.operationStatus) ? operationStatusEFromJSON(object.operationStatus) : 0,
    };
  },

  toJSON(message: WhitelistOperationStatus): unknown {
    const obj: any = {};
    if (message.whitelistOperationInformation !== 0) {
      obj.whitelistOperationInformation = whitelistOperationInformationEToJSON(message.whitelistOperationInformation);
    }
    if (message.signerOfOperation !== undefined) {
      obj.signerOfOperation = KeyIdentifier.toJSON(message.signerOfOperation);
    }
    if (message.operationStatus !== 0) {
      obj.operationStatus = operationStatusEToJSON(message.operationStatus);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<WhitelistOperationStatus>, I>>(base?: I): WhitelistOperationStatus {
    return WhitelistOperationStatus.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<WhitelistOperationStatus>, I>>(object: I): WhitelistOperationStatus {
    const message = createBaseWhitelistOperationStatus();
    message.whitelistOperationInformation = object.whitelistOperationInformation ?? 0;
    message.signerOfOperation = (object.signerOfOperation !== undefined && object.signerOfOperation !== null)
      ? KeyIdentifier.fromPartial(object.signerOfOperation)
      : undefined;
    message.operationStatus = object.operationStatus ?? 0;
    return message;
  },
};

function createBaseSignedMessageStatus(): SignedMessageStatus {
  return { counter: 0, signedMessageInformation: 0 };
}

export const SignedMessageStatus: MessageFns<SignedMessageStatus> = {
  encode(message: SignedMessageStatus, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.counter !== 0) {
      writer.uint32(8).uint32(message.counter);
    }
    if (message.signedMessageInformation !== 0) {
      writer.uint32(16).int32(message.signedMessageInformation);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SignedMessageStatus {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSignedMessageStatus();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.counter = reader.uint32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.signedMessageInformation = reader.int32() as any;
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SignedMessageStatus {
    return {
      counter: isSet(object.counter) ? globalThis.Number(object.counter) : 0,
      signedMessageInformation: isSet(object.signedMessageInformation)
        ? signedMessageInformationEFromJSON(object.signedMessageInformation)
        : 0,
    };
  },

  toJSON(message: SignedMessageStatus): unknown {
    const obj: any = {};
    if (message.counter !== 0) {
      obj.counter = Math.round(message.counter);
    }
    if (message.signedMessageInformation !== 0) {
      obj.signedMessageInformation = signedMessageInformationEToJSON(message.signedMessageInformation);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SignedMessageStatus>, I>>(base?: I): SignedMessageStatus {
    return SignedMessageStatus.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SignedMessageStatus>, I>>(object: I): SignedMessageStatus {
    const message = createBaseSignedMessageStatus();
    message.counter = object.counter ?? 0;
    message.signedMessageInformation = object.signedMessageInformation ?? 0;
    return message;
  },
};

function createBaseCommandStatus(): CommandStatus {
  return { operationStatus: 0, signedMessageStatus: undefined, whitelistOperationStatus: undefined };
}

export const CommandStatus: MessageFns<CommandStatus> = {
  encode(message: CommandStatus, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.operationStatus !== 0) {
      writer.uint32(8).int32(message.operationStatus);
    }
    if (message.signedMessageStatus !== undefined) {
      SignedMessageStatus.encode(message.signedMessageStatus, writer.uint32(18).fork()).join();
    }
    if (message.whitelistOperationStatus !== undefined) {
      WhitelistOperationStatus.encode(message.whitelistOperationStatus, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CommandStatus {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCommandStatus();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.operationStatus = reader.int32() as any;
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.signedMessageStatus = SignedMessageStatus.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.whitelistOperationStatus = WhitelistOperationStatus.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CommandStatus {
    return {
      operationStatus: isSet(object.operationStatus) ? operationStatusEFromJSON(object.operationStatus) : 0,
      signedMessageStatus: isSet(object.signedMessageStatus)
        ? SignedMessageStatus.fromJSON(object.signedMessageStatus)
        : undefined,
      whitelistOperationStatus: isSet(object.whitelistOperationStatus)
        ? WhitelistOperationStatus.fromJSON(object.whitelistOperationStatus)
        : undefined,
    };
  },

  toJSON(message: CommandStatus): unknown {
    const obj: any = {};
    if (message.operationStatus !== 0) {
      obj.operationStatus = operationStatusEToJSON(message.operationStatus);
    }
    if (message.signedMessageStatus !== undefined) {
      obj.signedMessageStatus = SignedMessageStatus.toJSON(message.signedMessageStatus);
    }
    if (message.whitelistOperationStatus !== undefined) {
      obj.whitelistOperationStatus = WhitelistOperationStatus.toJSON(message.whitelistOperationStatus);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CommandStatus>, I>>(base?: I): CommandStatus {
    return CommandStatus.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CommandStatus>, I>>(object: I): CommandStatus {
    const message = createBaseCommandStatus();
    message.operationStatus = object.operationStatus ?? 0;
    message.signedMessageStatus = (object.signedMessageStatus !== undefined && object.signedMessageStatus !== null)
      ? SignedMessageStatus.fromPartial(object.signedMessageStatus)
      : undefined;
    message.whitelistOperationStatus =
      (object.whitelistOperationStatus !== undefined && object.whitelistOperationStatus !== null)
        ? WhitelistOperationStatus.fromPartial(object.whitelistOperationStatus)
        : undefined;
    return message;
  },
};

function createBaseUnsignedMessage(): UnsignedMessage {
  return {
    InformationRequest: undefined,
    RKEAction: undefined,
    closureMoveRequest: undefined,
    WhitelistOperation: undefined,
  };
}

export const UnsignedMessage: MessageFns<UnsignedMessage> = {
  encode(message: UnsignedMessage, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.InformationRequest !== undefined) {
      InformationRequest.encode(message.InformationRequest, writer.uint32(10).fork()).join();
    }
    if (message.RKEAction !== undefined) {
      writer.uint32(16).int32(message.RKEAction);
    }
    if (message.closureMoveRequest !== undefined) {
      ClosureMoveRequest.encode(message.closureMoveRequest, writer.uint32(34).fork()).join();
    }
    if (message.WhitelistOperation !== undefined) {
      WhitelistOperation.encode(message.WhitelistOperation, writer.uint32(130).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UnsignedMessage {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUnsignedMessage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.InformationRequest = InformationRequest.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.RKEAction = reader.int32() as any;
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.closureMoveRequest = ClosureMoveRequest.decode(reader, reader.uint32());
          continue;
        }
        case 16: {
          if (tag !== 130) {
            break;
          }

          message.WhitelistOperation = WhitelistOperation.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UnsignedMessage {
    return {
      InformationRequest: isSet(object.InformationRequest)
        ? InformationRequest.fromJSON(object.InformationRequest)
        : undefined,
      RKEAction: isSet(object.RKEAction) ? rKEActionEFromJSON(object.RKEAction) : undefined,
      closureMoveRequest: isSet(object.closureMoveRequest)
        ? ClosureMoveRequest.fromJSON(object.closureMoveRequest)
        : undefined,
      WhitelistOperation: isSet(object.WhitelistOperation)
        ? WhitelistOperation.fromJSON(object.WhitelistOperation)
        : undefined,
    };
  },

  toJSON(message: UnsignedMessage): unknown {
    const obj: any = {};
    if (message.InformationRequest !== undefined) {
      obj.InformationRequest = InformationRequest.toJSON(message.InformationRequest);
    }
    if (message.RKEAction !== undefined) {
      obj.RKEAction = rKEActionEToJSON(message.RKEAction);
    }
    if (message.closureMoveRequest !== undefined) {
      obj.closureMoveRequest = ClosureMoveRequest.toJSON(message.closureMoveRequest);
    }
    if (message.WhitelistOperation !== undefined) {
      obj.WhitelistOperation = WhitelistOperation.toJSON(message.WhitelistOperation);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<UnsignedMessage>, I>>(base?: I): UnsignedMessage {
    return UnsignedMessage.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UnsignedMessage>, I>>(object: I): UnsignedMessage {
    const message = createBaseUnsignedMessage();
    message.InformationRequest = (object.InformationRequest !== undefined && object.InformationRequest !== null)
      ? InformationRequest.fromPartial(object.InformationRequest)
      : undefined;
    message.RKEAction = object.RKEAction ?? undefined;
    message.closureMoveRequest = (object.closureMoveRequest !== undefined && object.closureMoveRequest !== null)
      ? ClosureMoveRequest.fromPartial(object.closureMoveRequest)
      : undefined;
    message.WhitelistOperation = (object.WhitelistOperation !== undefined && object.WhitelistOperation !== null)
      ? WhitelistOperation.fromPartial(object.WhitelistOperation)
      : undefined;
    return message;
  },
};

function createBaseClosureStatuses(): ClosureStatuses {
  return {
    frontDriverDoor: 0,
    frontPassengerDoor: 0,
    rearDriverDoor: 0,
    rearPassengerDoor: 0,
    rearTrunk: 0,
    frontTrunk: 0,
    chargePort: 0,
    tonneau: 0,
  };
}

export const ClosureStatuses: MessageFns<ClosureStatuses> = {
  encode(message: ClosureStatuses, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.frontDriverDoor !== 0) {
      writer.uint32(8).int32(message.frontDriverDoor);
    }
    if (message.frontPassengerDoor !== 0) {
      writer.uint32(16).int32(message.frontPassengerDoor);
    }
    if (message.rearDriverDoor !== 0) {
      writer.uint32(24).int32(message.rearDriverDoor);
    }
    if (message.rearPassengerDoor !== 0) {
      writer.uint32(32).int32(message.rearPassengerDoor);
    }
    if (message.rearTrunk !== 0) {
      writer.uint32(40).int32(message.rearTrunk);
    }
    if (message.frontTrunk !== 0) {
      writer.uint32(48).int32(message.frontTrunk);
    }
    if (message.chargePort !== 0) {
      writer.uint32(56).int32(message.chargePort);
    }
    if (message.tonneau !== 0) {
      writer.uint32(64).int32(message.tonneau);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ClosureStatuses {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseClosureStatuses();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.frontDriverDoor = reader.int32() as any;
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.frontPassengerDoor = reader.int32() as any;
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.rearDriverDoor = reader.int32() as any;
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.rearPassengerDoor = reader.int32() as any;
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.rearTrunk = reader.int32() as any;
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.frontTrunk = reader.int32() as any;
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.chargePort = reader.int32() as any;
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.tonneau = reader.int32() as any;
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ClosureStatuses {
    return {
      frontDriverDoor: isSet(object.frontDriverDoor) ? closureStateEFromJSON(object.frontDriverDoor) : 0,
      frontPassengerDoor: isSet(object.frontPassengerDoor) ? closureStateEFromJSON(object.frontPassengerDoor) : 0,
      rearDriverDoor: isSet(object.rearDriverDoor) ? closureStateEFromJSON(object.rearDriverDoor) : 0,
      rearPassengerDoor: isSet(object.rearPassengerDoor) ? closureStateEFromJSON(object.rearPassengerDoor) : 0,
      rearTrunk: isSet(object.rearTrunk) ? closureStateEFromJSON(object.rearTrunk) : 0,
      frontTrunk: isSet(object.frontTrunk) ? closureStateEFromJSON(object.frontTrunk) : 0,
      chargePort: isSet(object.chargePort) ? closureStateEFromJSON(object.chargePort) : 0,
      tonneau: isSet(object.tonneau) ? closureStateEFromJSON(object.tonneau) : 0,
    };
  },

  toJSON(message: ClosureStatuses): unknown {
    const obj: any = {};
    if (message.frontDriverDoor !== 0) {
      obj.frontDriverDoor = closureStateEToJSON(message.frontDriverDoor);
    }
    if (message.frontPassengerDoor !== 0) {
      obj.frontPassengerDoor = closureStateEToJSON(message.frontPassengerDoor);
    }
    if (message.rearDriverDoor !== 0) {
      obj.rearDriverDoor = closureStateEToJSON(message.rearDriverDoor);
    }
    if (message.rearPassengerDoor !== 0) {
      obj.rearPassengerDoor = closureStateEToJSON(message.rearPassengerDoor);
    }
    if (message.rearTrunk !== 0) {
      obj.rearTrunk = closureStateEToJSON(message.rearTrunk);
    }
    if (message.frontTrunk !== 0) {
      obj.frontTrunk = closureStateEToJSON(message.frontTrunk);
    }
    if (message.chargePort !== 0) {
      obj.chargePort = closureStateEToJSON(message.chargePort);
    }
    if (message.tonneau !== 0) {
      obj.tonneau = closureStateEToJSON(message.tonneau);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ClosureStatuses>, I>>(base?: I): ClosureStatuses {
    return ClosureStatuses.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ClosureStatuses>, I>>(object: I): ClosureStatuses {
    const message = createBaseClosureStatuses();
    message.frontDriverDoor = object.frontDriverDoor ?? 0;
    message.frontPassengerDoor = object.frontPassengerDoor ?? 0;
    message.rearDriverDoor = object.rearDriverDoor ?? 0;
    message.rearPassengerDoor = object.rearPassengerDoor ?? 0;
    message.rearTrunk = object.rearTrunk ?? 0;
    message.frontTrunk = object.frontTrunk ?? 0;
    message.chargePort = object.chargePort ?? 0;
    message.tonneau = object.tonneau ?? 0;
    return message;
  },
};

function createBaseDetailedClosureStatus(): DetailedClosureStatus {
  return { tonneauPercentOpen: 0 };
}

export const DetailedClosureStatus: MessageFns<DetailedClosureStatus> = {
  encode(message: DetailedClosureStatus, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.tonneauPercentOpen !== 0) {
      writer.uint32(8).uint32(message.tonneauPercentOpen);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DetailedClosureStatus {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDetailedClosureStatus();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.tonneauPercentOpen = reader.uint32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DetailedClosureStatus {
    return { tonneauPercentOpen: isSet(object.tonneauPercentOpen) ? globalThis.Number(object.tonneauPercentOpen) : 0 };
  },

  toJSON(message: DetailedClosureStatus): unknown {
    const obj: any = {};
    if (message.tonneauPercentOpen !== 0) {
      obj.tonneauPercentOpen = Math.round(message.tonneauPercentOpen);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DetailedClosureStatus>, I>>(base?: I): DetailedClosureStatus {
    return DetailedClosureStatus.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DetailedClosureStatus>, I>>(object: I): DetailedClosureStatus {
    const message = createBaseDetailedClosureStatus();
    message.tonneauPercentOpen = object.tonneauPercentOpen ?? 0;
    return message;
  },
};

function createBaseVehicleStatus(): VehicleStatus {
  return {
    closureStatuses: undefined,
    vehicleLockState: 0,
    vehicleSleepStatus: 0,
    userPresence: 0,
    detailedClosureStatus: undefined,
  };
}

export const VehicleStatus: MessageFns<VehicleStatus> = {
  encode(message: VehicleStatus, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.closureStatuses !== undefined) {
      ClosureStatuses.encode(message.closureStatuses, writer.uint32(10).fork()).join();
    }
    if (message.vehicleLockState !== 0) {
      writer.uint32(16).int32(message.vehicleLockState);
    }
    if (message.vehicleSleepStatus !== 0) {
      writer.uint32(24).int32(message.vehicleSleepStatus);
    }
    if (message.userPresence !== 0) {
      writer.uint32(32).int32(message.userPresence);
    }
    if (message.detailedClosureStatus !== undefined) {
      DetailedClosureStatus.encode(message.detailedClosureStatus, writer.uint32(42).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): VehicleStatus {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseVehicleStatus();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.closureStatuses = ClosureStatuses.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.vehicleLockState = reader.int32() as any;
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.vehicleSleepStatus = reader.int32() as any;
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.userPresence = reader.int32() as any;
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.detailedClosureStatus = DetailedClosureStatus.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): VehicleStatus {
    return {
      closureStatuses: isSet(object.closureStatuses) ? ClosureStatuses.fromJSON(object.closureStatuses) : undefined,
      vehicleLockState: isSet(object.vehicleLockState) ? vehicleLockStateEFromJSON(object.vehicleLockState) : 0,
      vehicleSleepStatus: isSet(object.vehicleSleepStatus) ? vehicleSleepStatusEFromJSON(object.vehicleSleepStatus) : 0,
      userPresence: isSet(object.userPresence) ? userPresenceEFromJSON(object.userPresence) : 0,
      detailedClosureStatus: isSet(object.detailedClosureStatus)
        ? DetailedClosureStatus.fromJSON(object.detailedClosureStatus)
        : undefined,
    };
  },

  toJSON(message: VehicleStatus): unknown {
    const obj: any = {};
    if (message.closureStatuses !== undefined) {
      obj.closureStatuses = ClosureStatuses.toJSON(message.closureStatuses);
    }
    if (message.vehicleLockState !== 0) {
      obj.vehicleLockState = vehicleLockStateEToJSON(message.vehicleLockState);
    }
    if (message.vehicleSleepStatus !== 0) {
      obj.vehicleSleepStatus = vehicleSleepStatusEToJSON(message.vehicleSleepStatus);
    }
    if (message.userPresence !== 0) {
      obj.userPresence = userPresenceEToJSON(message.userPresence);
    }
    if (message.detailedClosureStatus !== undefined) {
      obj.detailedClosureStatus = DetailedClosureStatus.toJSON(message.detailedClosureStatus);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<VehicleStatus>, I>>(base?: I): VehicleStatus {
    return VehicleStatus.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<VehicleStatus>, I>>(object: I): VehicleStatus {
    const message = createBaseVehicleStatus();
    message.closureStatuses = (object.closureStatuses !== undefined && object.closureStatuses !== null)
      ? ClosureStatuses.fromPartial(object.closureStatuses)
      : undefined;
    message.vehicleLockState = object.vehicleLockState ?? 0;
    message.vehicleSleepStatus = object.vehicleSleepStatus ?? 0;
    message.userPresence = object.userPresence ?? 0;
    message.detailedClosureStatus =
      (object.detailedClosureStatus !== undefined && object.detailedClosureStatus !== null)
        ? DetailedClosureStatus.fromPartial(object.detailedClosureStatus)
        : undefined;
    return message;
  },
};

function createBaseFromVCSECMessage(): FromVCSECMessage {
  return {
    vehicleStatus: undefined,
    commandStatus: undefined,
    whitelistInfo: undefined,
    whitelistEntryInfo: undefined,
    nominalError: undefined,
  };
}

export const FromVCSECMessage: MessageFns<FromVCSECMessage> = {
  encode(message: FromVCSECMessage, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.vehicleStatus !== undefined) {
      VehicleStatus.encode(message.vehicleStatus, writer.uint32(10).fork()).join();
    }
    if (message.commandStatus !== undefined) {
      CommandStatus.encode(message.commandStatus, writer.uint32(34).fork()).join();
    }
    if (message.whitelistInfo !== undefined) {
      WhitelistInfo.encode(message.whitelistInfo, writer.uint32(130).fork()).join();
    }
    if (message.whitelistEntryInfo !== undefined) {
      WhitelistEntryInfo.encode(message.whitelistEntryInfo, writer.uint32(138).fork()).join();
    }
    if (message.nominalError !== undefined) {
      NominalError.encode(message.nominalError, writer.uint32(370).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): FromVCSECMessage {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFromVCSECMessage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.vehicleStatus = VehicleStatus.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.commandStatus = CommandStatus.decode(reader, reader.uint32());
          continue;
        }
        case 16: {
          if (tag !== 130) {
            break;
          }

          message.whitelistInfo = WhitelistInfo.decode(reader, reader.uint32());
          continue;
        }
        case 17: {
          if (tag !== 138) {
            break;
          }

          message.whitelistEntryInfo = WhitelistEntryInfo.decode(reader, reader.uint32());
          continue;
        }
        case 46: {
          if (tag !== 370) {
            break;
          }

          message.nominalError = NominalError.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FromVCSECMessage {
    return {
      vehicleStatus: isSet(object.vehicleStatus) ? VehicleStatus.fromJSON(object.vehicleStatus) : undefined,
      commandStatus: isSet(object.commandStatus) ? CommandStatus.fromJSON(object.commandStatus) : undefined,
      whitelistInfo: isSet(object.whitelistInfo) ? WhitelistInfo.fromJSON(object.whitelistInfo) : undefined,
      whitelistEntryInfo: isSet(object.whitelistEntryInfo)
        ? WhitelistEntryInfo.fromJSON(object.whitelistEntryInfo)
        : undefined,
      nominalError: isSet(object.nominalError) ? NominalError.fromJSON(object.nominalError) : undefined,
    };
  },

  toJSON(message: FromVCSECMessage): unknown {
    const obj: any = {};
    if (message.vehicleStatus !== undefined) {
      obj.vehicleStatus = VehicleStatus.toJSON(message.vehicleStatus);
    }
    if (message.commandStatus !== undefined) {
      obj.commandStatus = CommandStatus.toJSON(message.commandStatus);
    }
    if (message.whitelistInfo !== undefined) {
      obj.whitelistInfo = WhitelistInfo.toJSON(message.whitelistInfo);
    }
    if (message.whitelistEntryInfo !== undefined) {
      obj.whitelistEntryInfo = WhitelistEntryInfo.toJSON(message.whitelistEntryInfo);
    }
    if (message.nominalError !== undefined) {
      obj.nominalError = NominalError.toJSON(message.nominalError);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<FromVCSECMessage>, I>>(base?: I): FromVCSECMessage {
    return FromVCSECMessage.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<FromVCSECMessage>, I>>(object: I): FromVCSECMessage {
    const message = createBaseFromVCSECMessage();
    message.vehicleStatus = (object.vehicleStatus !== undefined && object.vehicleStatus !== null)
      ? VehicleStatus.fromPartial(object.vehicleStatus)
      : undefined;
    message.commandStatus = (object.commandStatus !== undefined && object.commandStatus !== null)
      ? CommandStatus.fromPartial(object.commandStatus)
      : undefined;
    message.whitelistInfo = (object.whitelistInfo !== undefined && object.whitelistInfo !== null)
      ? WhitelistInfo.fromPartial(object.whitelistInfo)
      : undefined;
    message.whitelistEntryInfo = (object.whitelistEntryInfo !== undefined && object.whitelistEntryInfo !== null)
      ? WhitelistEntryInfo.fromPartial(object.whitelistEntryInfo)
      : undefined;
    message.nominalError = (object.nominalError !== undefined && object.nominalError !== null)
      ? NominalError.fromPartial(object.nominalError)
      : undefined;
    return message;
  },
};

function bytesFromBase64(b64: string): Uint8Array {
  if ((globalThis as any).Buffer) {
    return Uint8Array.from(globalThis.Buffer.from(b64, "base64"));
  } else {
    const bin = globalThis.atob(b64);
    const arr = new Uint8Array(bin.length);
    for (let i = 0; i < bin.length; ++i) {
      arr[i] = bin.charCodeAt(i);
    }
    return arr;
  }
}

function base64FromBytes(arr: Uint8Array): string {
  if ((globalThis as any).Buffer) {
    return globalThis.Buffer.from(arr).toString("base64");
  } else {
    const bin: string[] = [];
    arr.forEach((byte) => {
      bin.push(globalThis.String.fromCharCode(byte));
    });
    return globalThis.btoa(bin.join(""));
  }
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
